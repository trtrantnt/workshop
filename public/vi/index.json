[
{
	"uri": "//localhost:62814/vi/1-gioi-thieu/",
	"title": "1. Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tổng quan Workshop Workshop này sẽ hướng dẫn bạn triển khai một hệ thống Identity Governance toàn diện với Access Certification trên AWS, bao gồm:\nAccess Governance: Quản lý và kiểm soát quyền truy cập Certification Automation: Tự động hóa quy trình xác nhận quyền Privilege Analytics: Phân tích và giám sát đặc quyền Risk Assessment: Đánh giá rủi ro bảo mật Monitoring Setup: Thiết lập giám sát liên tục Operational Procedures: Quy trình vận hành Audit Procedures: Quy trình kiểm toán Compliance Validation: Xác thực tuân thủ Kiến trúc Tổng thể AWS Services Sử dụng (Kiến trúc Tối giản) AWS IAM Identity Center - Quản lý truy cập tập trung AWS IAM - Quản lý danh tính và truy cập AWS Lambda - Hàm tự động hóa và xử lý Amazon EventBridge - Điều phối sự kiện Amazon DynamoDB - Lưu trữ dữ liệu certification Amazon S3 - Lưu trữ log và data lake AWS CloudTrail - Ghi log kiểm toán Amazon CloudWatch - Giám sát và metrics Amazon SNS - Thông báo và cảnh báo Amazon QuickSight - Dashboard phân tích AWS Security Hub - Đánh giá rủi ro và tuân thủ Lợi ích của Identity Governance 1. Bảo mật nâng cao Kiểm soát quyền truy cập chặt chẽ Phát hiện và ngăn chặn rủi ro bảo mật Giám sát liên tục các hoạt động 2. Tuân thủ quy định Đáp ứng các yêu cầu SOX, SOC2, ISO27001 Tự động hóa quy trình audit Lưu trữ bằng chứng tuân thủ 3. Hiệu quả vận hành Tự động hóa quy trình certification Giảm thiểu công việc thủ công Cải thiện quy trình quản lý Tiếp theo Chuyển sang 2. Các bước chuẩn bị để bắt đầu thiết lập môi trường.\n"
},
{
	"uri": "//localhost:62814/vi/",
	"title": "Quản trị Danh tính với Chứng nhận Truy cập",
	"tags": [],
	"description": "",
	"content": "Workshop Quản trị Danh tính với Chứng nhận Truy cập Tổng quan Workshop Workshop toàn diện này hướng dẫn bạn triển khai Quản trị Danh tính với Chứng nhận Truy cập trên AWS, bao gồm các thực hành bảo mật nâng cao và yêu cầu tuân thủ.\nCác Module Workshop 1. Giới thiệu\r2. Các bước chuẩn bị\r3. Thiết lập Access Governance\r4. Tự động hóa Certification\r5. Phân tích Đặc quyền\r6. Đánh giá Rủi ro\r7. Thiết lập Giám sát\r8. Quy trình Vận hành\r9. Quy trình Kiểm toán\r10. Xác thực Tuân thủ\r11. Dọn dẹp Tài nguyên\rTổng quan Kiến trúc Lợi ích Chính Bảo mật Nâng cao: Kiểm soát truy cập nghiêm ngặt và giám sát liên tục Tuân thủ Quy định: Đáp ứng yêu cầu SOX, SOC2, ISO27001 Hiệu quả Vận hành: Quy trình chứng nhận và khắc phục tự động Quản lý Rủi ro: Đánh giá và giảm thiểu rủi ro chủ động Yêu cầu Tiên quyết Tài khoản AWS với quyền Administrator Hiểu biết cơ bản về AWS IAM và Organizations Kiến thức về các framework tuân thủ Kinh nghiệm với Python và AWS CLI "
},
{
	"uri": "//localhost:62814/vi/2-cac-buoc-chuan-bi/",
	"title": "2. Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Thiết lập môi trường 1. Tạo S3 Bucket cho lưu trữ dữ liệu Điều hướng đến dịch vụ Amazon S3 trong AWS Console Click Create bucket Tạo bucket đầu tiên cho dữ liệu phân tích: Bucket name: identity-governance-analytics AWS Region: Chọn region ưa thích (ví dụ: us-east-1) Object Ownership: ACLs disabled (khuyến nghị) Block Public Access settings: Giữ tất cả đều bị chặn (khuyến nghị) Bucket Versioning: Kích hoạt Default encryption: Server-side encryption với Amazon S3 managed keys (SSE-S3) Bucket Key: Kích hoạt Click Create bucket Tạo bucket thứ hai cho báo cáo tuân thủ: Bucket name: identity-governance-reports AWS Region: Giống bucket đầu tiên Object Ownership: ACLs disabled (khuyến nghị) Block Public Access settings: Giữ tất cả đều bị chặn (khuyến nghị) Bucket Versioning: Kích hoạt Default encryption: Server-side encryption với Amazon S3 managed keys (SSE-S3) Bucket Key: Kích hoạt Object Lock: Kích hoạt cho compliance retention Click Create bucket Xác minh cả hai bucket đã được tạo thành công: Chuẩn bị Infrastructure 1. Kích hoạt AWS CloudTrail Điều hướng đến dịch vụ CloudTrail trong AWS Console Click Create trail Bước 1: General details Nhập thông tin cơ bản: Trail name: IdentityGovernanceTrail Enable for all accounts in my organization: Để trống (unchecked) Bước 2: S3 bucket configuration Cấu hình S3 storage:\nCreate new S3 bucket: Chọn option này (ĐỂ TRỐNG - KHÔNG chọn \u0026ldquo;Use existing S3 bucket\u0026rdquo;) S3 bucket name: CloudTrail sẽ tự động tạo tên (ví dụ: aws-cloudtrail-logs-123456789012-abc12345) Cấu hình bảo mật:\nLog file SSE-KMS encryption: Unchecked (giữ mặc định) Log file validation: Checked (khuyến nghị) Bước 3: CloudWatch Logs (Optional) CloudWatch Logs configuration:\nCloudWatch Logs: Unchecked (bỏ qua cho bây giờ) Click Next\nBước 4: Choose log events Chọn loại events để log: Management events: Checked Read: Checked Write: Checked Data events: Unchecked (bỏ qua) Insight events: Unchecked (bỏ qua) Click Next Bước 5: Review and create Kiểm tra lại cấu hình: Xác nhận trail name Xác nhận S3 bucket sẽ được tạo mới Xác nhận management events được bật Click Create trail QUAN TRỌNG: KHÔNG BAO GIỜ chọn bucket identity-governance-analytics hoặc bất kỳ bucket nào bạn đã tạo trước đó BẮT BUỘC chọn \u0026ldquo;Create new S3 bucket\u0026rdquo; để CloudTrail tự tạo bucket riêng CloudTrail sẽ tự động cấu hình bucket policy đúng, tránh lỗi InsufficientS3BucketPolicyException 2. Kích hoạt AWS Security Hub Điều hướng đến dịch vụ AWS Security Hub trong AWS Console Bạn sẽ thấy trang Security Hub Onboard Bước 1: Configure Security Hub Trong phần Configure Security Hub: Đọc thông tin về Service Linked Roles (SLRs) Để mặc định các cài đặt Bước 2: Delegated Administrator Account Trong phần Delegated administrator account: Chọn Do not select an account (cho single account setup) Bước 3: Account Enablement Trong phần Account enablement: ☑️ Enable Security Hub for my account (giữ checked) Bước 4: Delegated Administrator Policy Trong phần Delegated administrator policy: Đọc policy details Giữ cài đặt mặc định Click Onboard ở cuối trang Bước 5: Xác minh kích hoạt thành công Sau khi onboard thành công, bạn sẽ thấy Security Hub dashboard: Security score hiển thị Findings bắt đầu được thu thập Standards tự động kích hoạt 3. Tạo DynamoDB Tables Điều hướng đến dịch vụ DynamoDB Click Create table Tạo bảng đầu tiên: Table name: AccessCertifications Partition key: UserId (String) Sort key: CertificationDate (String) Billing mode: On-demand Click Create table\nTạo bảng thứ hai:\nTable name: RiskAssessments Partition key: AssessmentId (String) Billing mode: On-demand Click Create table\n4. Tạo IAM Roles cần thiết Điều hướng đến dịch vụ IAM Click Roles trong sidebar Click Create role Tạo role cho Lambda: Trusted entity: AWS service Service: Lambda Role name: IdentityGovernanceLambdaRole Policies: Attach AWSLambdaBasicExecutionRole Xác thực thiết lập 1. Kiểm tra các dịch vụ đã kích hoạt CloudTrail: Vào CloudTrail console, xác nhận trail đã được tạo và đang hoạt động S3: Vào S3 console, xác nhận 3 bucket đã được tạo (2 bucket của bạn + 1 CloudTrail bucket) Security Hub: Vào Security Hub console, xác nhận service đã được kích hoạt và có security score DynamoDB: Vào DynamoDB console, xác nhận 2 table đã được tạo IAM: Vào IAM console, xác nhận Lambda role đã được tạo 2. Kiểm tra quyền truy cập Vào IAM console Click Users và xác nhận user hiện tại có quyền cần thiết Click Roles và xác nhận các role đã được tạo Kết quả Mong đợi Sau khi hoàn thành các bước chuẩn bị:\n✅ AWS Account được cấu hình đúng ✅ Các AWS services cần thiết đã được enable ✅ Base infrastructure đã được deploy ✅ Permissions đã được validate ✅ Workshop materials đã sẵn sàng Tiếp theo Chuyển sang 3. Thiết lập Access Governance để bắt đầu triển khai hệ thống.\n"
},
{
	"uri": "//localhost:62814/vi/3-thiet-lap-access-governance/",
	"title": "3. Thiết lập Access Governance",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thiết lập nền tảng quản lý truy cập tập trung với AWS IAM Identity Center và IAM.\nBước 1: Thiết lập IAM Foundation 1.1 Tạo IAM Groups Điều hướng đến dịch vụ IAM trong AWS Console Click User groups trong sidebar Click Create group Nhập thông tin group: Group name: SecurityAuditors Click Create group 1.2 Tạo IAM Policies Click Policies trong sidebar Click Create policy Sử dụng JSON editor để tạo custom policy: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;iam:Get*\u0026#34;, \u0026#34;iam:List*\u0026#34;, \u0026#34;iam:Generate*\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudtrail:Get*\u0026#34;, \u0026#34;cloudtrail:List*\u0026#34;, \u0026#34;cloudtrail:Describe*\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Đặt tên policy: SecurityAuditPolicy Click Create policy Bước 2: Cấu hình IAM Identity Center 2.1 Kích hoạt IAM Identity Center Tìm kiếm và mở IAM Identity Center trong AWS Console Click Enable để kích hoạt IAM Identity Center Chọn region để lưu trữ identity store Chọn Use IAM Identity Center as my identity source 2.2 Tạo Permission Sets Trong IAM Identity Center, click Permission sets ở sidebar Click Create permission set Chọn Predefined permission set Chọn SecurityAudit từ dropdown Nhập thông tin: Name: SecurityAuditor Description: Read-only access for security auditing Session duration: 8 hours Click Next và Create Bước 3: Thiết lập Identity Store 3.1 Tạo Users và Groups Trong IAM Identity Center, click Users ở sidebar\nClick Add user\nNhập thông tin user:\nUsername: security-auditor Email: auditor@company.com First name: Security Last name: Auditor Click Next và Add user 3.2 Tạo Groups Click Groups ở sidebar\nClick Create group\nNhập:\nGroup name: SecurityAuditors Description: Security auditing team Add users to group\nChọn user security-auditor Click Create group\nBước 4: Gán Quyền Truy cập 4.1 Gán Permission Sets cho Accounts Click AWS accounts ở sidebar\nChọn account cần assign quyền\nClick Assign users or groups\nChọn Groups tab\nChọn group SecurityAuditors\nClick Next\nChọn permission set SecurityAuditor\nClick Next và Submit\nKết quả Mong đợi Sau khi hoàn thành bước này, bạn sẽ có:\n✅ IAM Groups và Policies được cấu hình ✅ IAM Identity Center được kích hoạt ✅ Permission Sets cho các vai trò governance ✅ Identity Store với groups và users ✅ Các assignment quyền được cấu hình Tiếp theo Chuyển sang 4. Tự động hóa Certification để thiết lập quy trình tự động hóa certification.\n"
},
{
	"uri": "//localhost:62814/vi/4-tu-dong-hoa-certification/",
	"title": "4. Tự động hóa Certification",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Tự động hóa quy trình access certification để đảm bảo quyền truy cập được xem xét định kỳ và tuân thủ các yêu cầu bảo mật.\nBước 1: Xác minh DynamoDB Table 1.1 Kiểm tra Table đã tạo Mở Amazon DynamoDB trong console Xác minh table AccessCertifications đã được tạo trong chương 2 Table này sẽ được sử dụng để lưu certification data Bước 2: Tạo Lambda Function 2.1 Tạo Lambda Function Mở AWS Lambda trong console Click Create function Chọn Author from scratch Nhập thông tin function: Function name: AccessCertificationTrigger Runtime: Python 3.9 Architecture: x86_64 Click Create function 2.2 Cấu hình Code cho Lambda Function Trong tab Code, thay thế code mặc định bằng code sau: import json import boto3 from datetime import datetime def lambda_handler(event, context): print(\u0026#34;Access Certification Trigger Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) # Create certification record response = table.put_item( Item={ \u0026#39;UserId\u0026#39;: \u0026#39;system\u0026#39;, \u0026#39;CertificationDate\u0026#39;: datetime.now().isoformat(), \u0026#39;Status\u0026#39;: \u0026#39;Triggered\u0026#39;, \u0026#39;Type\u0026#39;: \u0026#39;Quarterly Review\u0026#39; } ) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Certification process triggered successfully\u0026#39;) } Click Deploy để lưu thay đổi 2.3 Cấu hình IAM Role cho Lambda Chuyển đến tab Configuration Click Permissions Click vào role name để mở IAM console Click Add permissions → Attach policies Tìm và attach policy AmazonDynamoDBFullAccess Chọn Add permissions Bước 3: Thiết lập EventBridge Scheduler 3.1 Tạo Scheduled Rule Mở Amazon EventBridge trong AWS Console Click Rules ở sidebar Click Create rule Bước 1: Define rule detail Nhập thông tin rule:\nName: AccessCertificationSchedule Description: Quarterly access certification review Event bus: default Enable the rule on the selected event bus Trong Rule type, chọn Schedule\nClick Next\nBước 2: Define schedule Trong Occurrence, chọn Recurring schedule Trong Schedule pattern, chọn Rate-based schedule Nhập 90 và chọn Days 10. Trong Flexible time window, nhập 15 minutes 11. Click Next\nBước 3: Select target Trong Target API, chọn AWS Lambda Invoke Trong Lambda function, chọn AccessCertificationTrigger Click Next Bước 4: Configure tags (Optional) Bỏ qua phần tags, click Next Bước 5: Review and create Xem lại cấu hình và click Create rule Bước 4: Kiểm tra Tự động hóa 4.1 Kiểm tra EventBridge Schedule Trong Amazon EventBridge console Click Schedules ở sidebar (không phải Rules) Xác minh schedule AccessCertificationSchedule đã được tạo và đang Enabled 4.2 Test Lambda Function thủ công Vào AWS Lambda console Chọn function AccessCertificationTrigger Click Test để tạo test event Sử dụng default test event và click Test Kiểm tra kết quả thực thi 4.3 Xác minh DynamoDB Record Vào Amazon DynamoDB console Chọn table AccessCertifications Click Explore table items Xác minh có record mới được tạo bởi Lambda function Kết quả Mong đợi Sau khi hoàn thành:\n✅ DynamoDB table để lưu certification data ✅ Lambda function xử lý certification logic ✅ EventBridge scheduled triggers hàng quý ✅ Tự động hóa đánh giá truy cập định kỳ ✅ Audit trail và giám sát Tiếp theo Chuyển sang 5. Phân tích Đặc quyền để thiết lập phân tích đặc quyền.\n"
},
{
	"uri": "//localhost:62814/vi/5-phan-tich-dac-quyen/",
	"title": "5. Phân tích Đặc quyền",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Phân tích và giám sát việc sử dụng đặc quyền để phát hiện rủi ro bảo mật, quyền thừa, và các pattern bất thường thông qua CloudTrail logs.\nBước 1: Xác minh CloudTrail Data 1.1 Kiểm tra CloudTrail Logs Mở Amazon CloudTrail trong console Xác minh trail IdentityGovernanceTrail đã được tạo trong chương 2 Kiểm tra S3 bucket chứa CloudTrail logs 1.2 Xác minh S3 Bucket có CloudTrail Data Vào Amazon S3 console Tìm bucket CloudTrail (tên dạng aws-cloudtrail-logs-xxx) Xác minh có log files được tạo Bước 2: Tạo Lambda Function cho Privilege Analytics 2.1 Tạo Lambda Function Mở AWS Lambda trong console Click Create function Chọn Author from scratch Nhập thông tin function: Function name: PrivilegeAnalyticsEngine Runtime: Python 3.9 Architecture: x86_64 Click Create function 2.2 Cấu hình Code cho Lambda Function Trong tab Code, thay thế code mặc định bằng code sau: import json import boto3 import gzip from datetime import datetime, timedelta from urllib.parse import unquote_plus def lambda_handler(event, context): print(\u0026#34;Privilege Analytics Engine Started\u0026#34;) # Initialize AWS clients s3 = boto3.client(\u0026#39;s3\u0026#39;) dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) # Get the object from the event bucket = event[\u0026#39;Records\u0026#39;][0][\u0026#39;s3\u0026#39;][\u0026#39;bucket\u0026#39;][\u0026#39;name\u0026#39;] key = unquote_plus(event[\u0026#39;Records\u0026#39;][0][\u0026#39;s3\u0026#39;][\u0026#39;object\u0026#39;][\u0026#39;key\u0026#39;]) try: # Download and decompress CloudTrail log response = s3.get_object(Bucket=bucket, Key=key) if key.endswith(\u0026#39;.gz\u0026#39;): content = gzip.decompress(response[\u0026#39;Body\u0026#39;].read()) else: content = response[\u0026#39;Body\u0026#39;].read() # Parse CloudTrail log log_data = json.loads(content.decode(\u0026#39;utf-8\u0026#39;)) # Analyze privilege usage privilege_events = analyze_privilege_events(log_data[\u0026#39;Records\u0026#39;]) # Store analysis results store_analysis_results(privilege_events, dynamodb) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Processed {len(privilege_events)} privilege events\u0026#39;) } except Exception as e: print(f\u0026#39;Error processing {key}: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def analyze_privilege_events(records): \u0026#34;\u0026#34;\u0026#34;Analyze CloudTrail records for privilege usage patterns\u0026#34;\u0026#34;\u0026#34; privilege_events = [] high_privilege_actions = [ \u0026#39;CreateUser\u0026#39;, \u0026#39;DeleteUser\u0026#39;, \u0026#39;AttachUserPolicy\u0026#39;, \u0026#39;DetachUserPolicy\u0026#39;, \u0026#39;CreateRole\u0026#39;, \u0026#39;DeleteRole\u0026#39;, \u0026#39;AttachRolePolicy\u0026#39;, \u0026#39;DetachRolePolicy\u0026#39;, \u0026#39;PutUserPolicy\u0026#39;, \u0026#39;DeleteUserPolicy\u0026#39;, \u0026#39;PutRolePolicy\u0026#39;, \u0026#39;DeleteRolePolicy\u0026#39; ] for record in records: event_name = record.get(\u0026#39;eventName\u0026#39;, \u0026#39;\u0026#39;) if event_name in high_privilege_actions: privilege_event = { \u0026#39;eventTime\u0026#39;: record.get(\u0026#39;eventTime\u0026#39;), \u0026#39;eventName\u0026#39;: event_name, \u0026#39;userIdentity\u0026#39;: record.get(\u0026#39;userIdentity\u0026#39;, {}), \u0026#39;sourceIPAddress\u0026#39;: record.get(\u0026#39;sourceIPAddress\u0026#39;), \u0026#39;userAgent\u0026#39;: record.get(\u0026#39;userAgent\u0026#39;), \u0026#39;awsRegion\u0026#39;: record.get(\u0026#39;awsRegion\u0026#39;), \u0026#39;riskScore\u0026#39;: calculate_risk_score(record) } privilege_events.append(privilege_event) return privilege_events def calculate_risk_score(record): \u0026#34;\u0026#34;\u0026#34;Calculate risk score for privilege event (1-10 scale)\u0026#34;\u0026#34;\u0026#34; base_score = 5 # High-risk actions high_risk_actions = [\u0026#39;DeleteUser\u0026#39;, \u0026#39;DeleteRole\u0026#39;, \u0026#39;DetachUserPolicy\u0026#39;] if record.get(\u0026#39;eventName\u0026#39;) in high_risk_actions: base_score += 3 # External IP access source_ip = record.get(\u0026#39;sourceIPAddress\u0026#39;, \u0026#39;\u0026#39;) if not source_ip.startswith(\u0026#39;10.\u0026#39;) and not source_ip.startswith(\u0026#39;172.\u0026#39;) and not source_ip.startswith(\u0026#39;192.168.\u0026#39;): base_score += 2 # Console vs API access user_agent = record.get(\u0026#39;userAgent\u0026#39;, \u0026#39;\u0026#39;) if \u0026#39;console\u0026#39; not in user_agent.lower(): base_score += 1 return min(base_score, 10) def store_analysis_results(privilege_events, dynamodb): \u0026#34;\u0026#34;\u0026#34;Store analysis results in DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) for event in privilege_events: table.put_item( Item={ \u0026#39;AssessmentId\u0026#39;: f\u0026#34;privilege-{datetime.now().isoformat()}\u0026#34;, \u0026#39;EventTime\u0026#39;: event[\u0026#39;eventTime\u0026#39;], \u0026#39;EventName\u0026#39;: event[\u0026#39;eventName\u0026#39;], \u0026#39;UserIdentity\u0026#39;: json.dumps(event[\u0026#39;userIdentity\u0026#39;]), \u0026#39;SourceIP\u0026#39;: event[\u0026#39;sourceIPAddress\u0026#39;], \u0026#39;RiskScore\u0026#39;: event[\u0026#39;riskScore\u0026#39;], \u0026#39;AssessmentType\u0026#39;: \u0026#39;Privilege Analysis\u0026#39; } ) Click Deploy để lưu thay đổi 2.3 Cấu hình IAM Role cho Lambda Chuyển đến tab Configuration Click Permissions Click vào role name để mở IAM console Click Add permissions → Attach policies Tìm và attach các policies sau: AmazonS3ReadOnlyAccess AmazonDynamoDBFullAccess Click Add permissions Bước 3: Thiết lập S3 Event Trigger 3.1 Cấu hình S3 Trigger cho Lambda Trong Lambda function PrivilegeAnalyticsEngine Click Add trigger Chọn S3 từ dropdown Cấu hình trigger: Bucket: Chọn CloudTrail S3 bucket Event type: All object create events Prefix: AWSLogs/ (optional) Suffix: .json.gz Click Add Bước 4: Tạo CloudWatch Dashboard 4.1 Tạo Dashboard cho Privilege Analytics Mở Amazon CloudWatch console Click Dashboards ở sidebar Click Create dashboard Nhập dashboard name: PrivilegeAnalyticsDashboard Click Create dashboard 4.2 Thêm Widget 1: Lambda Invocations Click Add widget Chọn Line chart Click Next Cấu hình metric: Namespace: AWS/Lambda Metric name: Invocations Dimensions: FunctionName = PrivilegeAnalyticsEngine Click Select metric Đặt tên widget: \u0026ldquo;Lambda Invocations\u0026rdquo; Click Create widget 4.3 Thêm Widget 2: Lambda Errors Click Add widget (trong dashboard) Chọn Line chart → Next Cấu hình metric: Namespace: AWS/Lambda Metric name: Errors Dimensions: FunctionName = PrivilegeAnalyticsEngine Click Select metric Đặt tên widget: \u0026ldquo;Lambda Errors\u0026rdquo; Click Create widget 4.4 Thêm Widget 3: Lambda Duration Click Add widget Chọn Line chart → Next Cấu hình metric: Namespace: AWS/Lambda Metric name: Duration Dimensions: FunctionName = PrivilegeAnalyticsEngine Click Select metric Đặt tên widget: \u0026ldquo;Lambda Duration (ms)\u0026rdquo; Click Create widget 4.5 Thêm Widget 4: DynamoDB Write Activity Click Add widget Chọn Line chart → Next Cấu hình metric: Namespace: AWS/DynamoDB Metric name: ConsumedWriteCapacityUnits Dimensions: TableName = RiskAssessments Click Select metric Đặt tên widget: \u0026ldquo;DynamoDB Write Activity\u0026rdquo; Click Create widget Lưu ý: Metric này hiển thị hoạt động ghi vào DynamoDB, cho biết khi nào có risk assessments mới được lưu trữ.\n4.6 Lưu Dashboard Click Save dashboard ở góc trên bên phải Dashboard sẽ hiển thị 4 widgets theo dõi: Số lần Lambda được gọi Số lỗi Lambda Thời gian thực thi Lambda Số lượng items trong DynamoDB Bước 5: Kiểm tra Privilege Analytics 5.1 Tạo Test User để Generate CloudTrail Events Vào IAM console Click Users ở sidebar trái Click Create user Nhập User name: test-privilege-user Click Next Chọn Attach policies directly Tìm và chọn ReadOnlyAccess Click Next → Create user 5.2 Thực hiện High-Privilege Actions Trong IAM console, chọn user test-privilege-user vừa tạo Click tab Permissions Click Add permissions → Attach policies directly Tìm và attach PowerUserAccess policy Click Add permissions Sau đó Remove policy PowerUserAccess để tạo thêm events Tạo test role: Click Roles ở sidebar Click Create role Chọn AWS service → Lambda Click Next → Next Role name: test-privilege-role Click Create role 5.3 Chờ CloudTrail Processing CloudTrail cần thời gian để ghi logs vào S3 Kiểm tra S3 bucket CloudTrail: Vào S3 console Tìm bucket CloudTrail (tên dạng aws-cloudtrail-logs-xxx) Xem có log files mới được tạo không 5.4 Xác minh Lambda Function Execution Vào AWS Lambda console Chọn function PrivilegeAnalyticsEngine Click tab Monitor Kiểm tra Invocations graph - should show activity Click View CloudWatch logs Chọn log stream mới nhất Xác minh có logs như: Privilege Analytics Engine Started Processed X privilege events 5.5 Xác minh DynamoDB Records Vào Amazon DynamoDB console Click Tables ở sidebar Chọn table RiskAssessments Click Explore table items Xác minh có records mới với: AssessmentType: \u0026lsquo;Privilege Analysis\u0026rsquo; EventName: \u0026lsquo;AttachUserPolicy\u0026rsquo;, \u0026lsquo;DetachUserPolicy\u0026rsquo;, \u0026lsquo;CreateRole\u0026rsquo; RiskScore: Giá trị từ 1-10 EventTime: Timestamp gần đây 5.6 Kiểm tra CloudWatch Dashboard Vào CloudWatch console Click Dashboards Chọn PrivilegeAnalyticsDashboard Xác minh các widgets hiển thị data: Lambda Invocations: Có spike khi function chạy Lambda Errors: Nên là 0 Lambda Duration: Thời gian execution DynamoDB Write Activity: Có activity khi ghi data 5.7 Test Real-time Monitoring Thực hiện thêm privilege action: Tạo user mới: test-user-2 Attach policy IAMReadOnlyAccess Chờ 5-10 phút Refresh DynamoDB table để xem record mới Kiểm tra dashboard có cập nhật metrics không 5.8 Troubleshooting (nếu không có data) Nếu Lambda không chạy:\nKiểm tra S3 trigger đã được cấu hình đúng Xem CloudTrail có tạo log files trong S3 không Kiểm tra IAM permissions của Lambda role Nếu không có data trong DynamoDB:\nXem CloudWatch logs của Lambda function Kiểm tra table name trong code: \u0026lsquo;RiskAssessments\u0026rsquo; Xác minh Lambda có quyền write vào DynamoDB Nếu Dashboard không hiển thị data:\nĐợi 5-15 phút để metrics xuất hiện Kiểm tra metric names và dimensions đúng không Refresh dashboard page Kết quả Mong đợi Sau khi hoàn thành:\n✅ CloudTrail logs được phân tích tự động ✅ Lambda function xử lý privilege events ✅ Risk scoring cho các privilege actions ✅ DynamoDB lưu trữ kết quả phân tích ✅ CloudWatch dashboard giám sát ✅ Real-time privilege monitoring Tiếp theo Chuyển sang 6. Đánh giá Rủi ro để thiết lập đánh giá rủi ro toàn diện.\n"
},
{
	"uri": "//localhost:62814/vi/6-danh-gia-rui-ro/",
	"title": "6. Đánh giá Rủi ro",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thiết lập hệ thống đánh giá rủi ro toàn diện để phân tích và scoring rủi ro bảo mật dựa trên dữ liệu từ các chương trước.\nBước 1: Xác minh Dữ liệu từ Các Chương Trước 1.1 Kiểm tra DynamoDB Tables Mở Amazon DynamoDB trong console Xác minh các tables đã có dữ liệu: AccessCertifications (từ chương 4) RiskAssessments (từ chương 5) 1.2 Kiểm tra Security Hub Findings Vào AWS Security Hub console Xác minh có findings được thu thập Kiểm tra compliance standards đang active Bước 2: Tạo Lambda Function cho Risk Assessment 2.1 Tạo Lambda Function Mở AWS Lambda trong console\nClick Create function\nChọn Author from scratch\nNhập thông tin function:\nFunction name: RiskAssessmentEngine Runtime: Python 3.9 Architecture: x86_64 Click Create function\n2.2 Cấu hình Code cho Lambda Function Trong tab Code, thay thế code mặc định bằng code sau: import json import boto3 from datetime import datetime, timedelta from decimal import Decimal def lambda_handler(event, context): print(\u0026#34;Risk Assessment Engine Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) securityhub = boto3.client(\u0026#39;securityhub\u0026#39;) iam = boto3.client(\u0026#39;iam\u0026#39;) try: # Collect data from various sources certification_data = get_certification_data(dynamodb) privilege_data = get_privilege_analysis_data(dynamodb) security_findings = get_security_hub_findings(securityhub) iam_data = get_iam_data(iam) # Perform comprehensive risk assessment risk_assessment = perform_risk_assessment( certification_data, privilege_data, security_findings, iam_data ) # Store assessment results store_risk_assessment(risk_assessment, dynamodb) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Risk assessment completed\u0026#39;, \u0026#39;totalUsers\u0026#39;: len(risk_assessment[\u0026#39;user_risks\u0026#39;]), \u0026#39;highRiskUsers\u0026#39;: len([u for u in risk_assessment[\u0026#39;user_risks\u0026#39;] if u[\u0026#39;riskLevel\u0026#39;] == \u0026#39;HIGH\u0026#39;]), \u0026#39;overallRiskScore\u0026#39;: risk_assessment[\u0026#39;overall_risk_score\u0026#39;] }) } except Exception as e: print(f\u0026#39;Error in risk assessment: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def get_certification_data(dynamodb): \u0026#34;\u0026#34;\u0026#34;Get certification data from DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) response = table.scan() return response[\u0026#39;Items\u0026#39;] def get_privilege_analysis_data(dynamodb): \u0026#34;\u0026#34;\u0026#34;Get privilege analysis data from DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;Privilege Analysis\u0026#39;} ) return response[\u0026#39;Items\u0026#39;] def get_security_hub_findings(securityhub): \u0026#34;\u0026#34;\u0026#34;Get Security Hub findings\u0026#34;\u0026#34;\u0026#34; try: response = securityhub.get_findings( Filters={ \u0026#39;RecordState\u0026#39;: [{\u0026#39;Value\u0026#39;: \u0026#39;ACTIVE\u0026#39;, \u0026#39;Comparison\u0026#39;: \u0026#39;EQUALS\u0026#39;}], \u0026#39;WorkflowStatus\u0026#39;: [{\u0026#39;Value\u0026#39;: \u0026#39;NEW\u0026#39;, \u0026#39;Comparison\u0026#39;: \u0026#39;EQUALS\u0026#39;}] }, MaxResults=100 ) return response[\u0026#39;Findings\u0026#39;] except Exception as e: print(f\u0026#39;Error getting Security Hub findings: {str(e)}\u0026#39;) return [] def get_iam_data(iam): \u0026#34;\u0026#34;\u0026#34;Get IAM users and roles data\u0026#34;\u0026#34;\u0026#34; users = [] roles = [] try: # Get users paginator = iam.get_paginator(\u0026#39;list_users\u0026#39;) for page in paginator.paginate(): users.extend(page[\u0026#39;Users\u0026#39;]) # Get roles paginator = iam.get_paginator(\u0026#39;list_roles\u0026#39;) for page in paginator.paginate(): roles.extend(page[\u0026#39;Roles\u0026#39;]) except Exception as e: print(f\u0026#39;Error getting IAM data: {str(e)}\u0026#39;) return {\u0026#39;users\u0026#39;: users, \u0026#39;roles\u0026#39;: roles} def perform_risk_assessment(cert_data, priv_data, sec_findings, iam_data): \u0026#34;\u0026#34;\u0026#34;Perform comprehensive risk assessment\u0026#34;\u0026#34;\u0026#34; user_risks = [] # Assess each user for user in iam_data[\u0026#39;users\u0026#39;]: user_name = user[\u0026#39;UserName\u0026#39;] # Calculate risk factors cert_risk = calculate_certification_risk(user_name, cert_data) priv_risk = calculate_privilege_risk(user_name, priv_data) security_risk = calculate_security_findings_risk(user_name, sec_findings) access_risk = calculate_access_pattern_risk(user) # Calculate overall user risk score overall_score = (cert_risk * 0.25 + priv_risk * 0.35 + security_risk * 0.25 + access_risk * 0.15) risk_level = get_risk_level(overall_score) user_risk = { \u0026#39;userName\u0026#39;: user_name, \u0026#39;riskScore\u0026#39;: round(overall_score, 2), \u0026#39;riskLevel\u0026#39;: risk_level, \u0026#39;factors\u0026#39;: { \u0026#39;certification\u0026#39;: cert_risk, \u0026#39;privilege\u0026#39;: priv_risk, \u0026#39;security\u0026#39;: security_risk, \u0026#39;access\u0026#39;: access_risk }, \u0026#39;assessmentDate\u0026#39;: datetime.now().isoformat() } user_risks.append(user_risk) # Calculate overall organizational risk if user_risks: overall_risk_score = sum(u[\u0026#39;riskScore\u0026#39;] for u in user_risks) / len(user_risks) else: overall_risk_score = 0 return { \u0026#39;user_risks\u0026#39;: user_risks, \u0026#39;overall_risk_score\u0026#39;: round(overall_risk_score, 2), \u0026#39;assessment_date\u0026#39;: datetime.now().isoformat(), \u0026#39;total_findings\u0026#39;: len(sec_findings) } def calculate_certification_risk(user_name, cert_data): \u0026#34;\u0026#34;\u0026#34;Calculate certification-related risk\u0026#34;\u0026#34;\u0026#34; base_risk = 5.0 # Check if user has recent certifications user_certs = [c for c in cert_data if c.get(\u0026#39;UserId\u0026#39;) == user_name] if not user_certs: return 8.0 # High risk if no certifications # Check certification recency recent_cert = max(user_certs, key=lambda x: x.get(\u0026#39;CertificationDate\u0026#39;, \u0026#39;\u0026#39;)) cert_date = datetime.fromisoformat(recent_cert[\u0026#39;CertificationDate\u0026#39;].replace(\u0026#39;Z\u0026#39;, \u0026#39;+00:00\u0026#39;)) days_since_cert = (datetime.now(cert_date.tzinfo) - cert_date).days if days_since_cert \u0026gt; 90: base_risk += 2 elif days_since_cert \u0026gt; 30: base_risk += 1 return min(base_risk, 10.0) def calculate_privilege_risk(user_name, priv_data): \u0026#34;\u0026#34;\u0026#34;Calculate privilege-related risk\u0026#34;\u0026#34;\u0026#34; user_priv_events = [p for p in priv_data if user_name in str(p.get(\u0026#39;UserIdentity\u0026#39;, \u0026#39;\u0026#39;))] if not user_priv_events: return 3.0 # Low risk if no privilege events # Calculate average risk score from privilege events avg_risk = sum(float(p.get(\u0026#39;RiskScore\u0026#39;, 5)) for p in user_priv_events) / len(user_priv_events) return min(avg_risk, 10.0) def calculate_security_findings_risk(user_name, findings): \u0026#34;\u0026#34;\u0026#34;Calculate risk based on Security Hub findings\u0026#34;\u0026#34;\u0026#34; base_risk = 2.0 # Count findings related to IAM/access iam_findings = [f for f in findings if \u0026#39;iam\u0026#39; in f.get(\u0026#39;Type\u0026#39;, \u0026#39;\u0026#39;).lower() or \u0026#39;access\u0026#39; in f.get(\u0026#39;Title\u0026#39;, \u0026#39;\u0026#39;).lower()] if len(iam_findings) \u0026gt; 5: base_risk += 4 elif len(iam_findings) \u0026gt; 2: base_risk += 2 elif len(iam_findings) \u0026gt; 0: base_risk += 1 return min(base_risk, 10.0) def calculate_access_pattern_risk(user): \u0026#34;\u0026#34;\u0026#34;Calculate risk based on access patterns\u0026#34;\u0026#34;\u0026#34; base_risk = 3.0 # Check password age password_last_used = user.get(\u0026#39;PasswordLastUsed\u0026#39;) if password_last_used: days_since_login = (datetime.now(password_last_used.tzinfo) - password_last_used).days if days_since_login \u0026gt; 90: base_risk += 2 elif days_since_login \u0026gt; 30: base_risk += 1 else: base_risk += 3 # Never logged in return min(base_risk, 10.0) def get_risk_level(score): \u0026#34;\u0026#34;\u0026#34;Convert risk score to risk level\u0026#34;\u0026#34;\u0026#34; if score \u0026gt;= 8: return \u0026#39;CRITICAL\u0026#39; elif score \u0026gt;= 6: return \u0026#39;HIGH\u0026#39; elif score \u0026gt;= 4: return \u0026#39;MEDIUM\u0026#39; else: return \u0026#39;LOW\u0026#39; def store_risk_assessment(assessment, dynamodb): \u0026#34;\u0026#34;\u0026#34;Store risk assessment results in DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Store overall assessment table.put_item( Item={ \u0026#39;AssessmentId\u0026#39;: f\u0026#34;risk-assessment-{datetime.now().isoformat()}\u0026#34;, \u0026#39;AssessmentType\u0026#39;: \u0026#39;Comprehensive Risk Assessment\u0026#39;, \u0026#39;OverallRiskScore\u0026#39;: Decimal(str(assessment[\u0026#39;overall_risk_score\u0026#39;])), \u0026#39;TotalUsers\u0026#39;: len(assessment[\u0026#39;user_risks\u0026#39;]), \u0026#39;HighRiskUsers\u0026#39;: len([u for u in assessment[\u0026#39;user_risks\u0026#39;] if u[\u0026#39;riskLevel\u0026#39;] in [\u0026#39;HIGH\u0026#39;, \u0026#39;CRITICAL\u0026#39;]]), \u0026#39;AssessmentDate\u0026#39;: assessment[\u0026#39;assessment_date\u0026#39;] } ) # Store individual user risks for user_risk in assessment[\u0026#39;user_risks\u0026#39;]: table.put_item( Item={ \u0026#39;AssessmentId\u0026#39;: f\u0026#34;user-risk-{user_risk[\u0026#39;userName\u0026#39;]}-{datetime.now().isoformat()}\u0026#34;, \u0026#39;AssessmentType\u0026#39;: \u0026#39;User Risk Assessment\u0026#39;, \u0026#39;UserName\u0026#39;: user_risk[\u0026#39;userName\u0026#39;], \u0026#39;RiskScore\u0026#39;: Decimal(str(user_risk[\u0026#39;riskScore\u0026#39;])), \u0026#39;RiskLevel\u0026#39;: user_risk[\u0026#39;riskLevel\u0026#39;], \u0026#39;CertificationRisk\u0026#39;: Decimal(str(user_risk[\u0026#39;factors\u0026#39;][\u0026#39;certification\u0026#39;])), \u0026#39;PrivilegeRisk\u0026#39;: Decimal(str(user_risk[\u0026#39;factors\u0026#39;][\u0026#39;privilege\u0026#39;])), \u0026#39;SecurityRisk\u0026#39;: Decimal(str(user_risk[\u0026#39;factors\u0026#39;][\u0026#39;security\u0026#39;])), \u0026#39;AccessRisk\u0026#39;: Decimal(str(user_risk[\u0026#39;factors\u0026#39;][\u0026#39;access\u0026#39;])), \u0026#39;AssessmentDate\u0026#39;: user_risk[\u0026#39;assessmentDate\u0026#39;] } ) Click Deploy để lưu thay đổi 2.3 Cấu hình IAM Role cho Lambda Chuyển đến tab Configuration Click Permissions Click vào role name để mở IAM console Click Add permissions → Attach policies Tìm và attach các policies sau: AmazonDynamoDBFullAccess SecurityHubReadOnlyAccess IAMReadOnlyAccess Click Add permissions Bước 3: Thiết lập EventBridge Schedule cho Risk Assessment 3.1 Tạo Scheduled Rule Mở Amazon EventBridge trong AWS Console Click Schedules ở sidebar Click Create schedule Cấu hình schedule: Name: RiskAssessmentSchedule Description: Daily risk assessment execution Schedule pattern: Rate-based schedule Rate: 1 Day Target: Lambda function RiskAssessmentEngine Click Create schedule Bước 4: Tạo SNS Topic cho Risk Alerts 4.1 Tạo SNS Topic Mở Amazon SNS console Click Topics ở sidebar Click Create topic Cấu hình topic: Type: Standard Name: RiskAssessmentAlerts Display name: Risk Assessment Alerts Click Create topic 4.2 Tạo Subscription Trong topic RiskAssessmentAlerts\nClick Create subscription\nCấu hình subscription:\nProtocol: Email Endpoint: your-email@example.com Click Create subscription\nXác nhận subscription qua email\nBước 5: Kiểm tra Risk Assessment 5.1 Test Lambda Function Vào AWS Lambda console Chọn function RiskAssessmentEngine Click Test để tạo test event Sử dụng default test event và click Test 5.2 Xác minh DynamoDB Results Vào Amazon DynamoDB console Chọn table RiskAssessments Click Explore table items Xác minh có records mới với AssessmentType = \u0026lsquo;Comprehensive Risk Assessment\u0026rsquo; 5.3 Kiểm tra CloudWatch Logs Vào Amazon CloudWatch console Click Log groups Tìm log group cho Lambda function Xem logs để xác minh risk assessment đã chạy thành công Kết quả Mong đợi Sau khi hoàn thành:\n✅ Comprehensive risk assessment engine ✅ Multi-factor risk scoring (certification, privilege, security, access) ✅ Automated daily risk assessments ✅ Risk level categorization (LOW, MEDIUM, HIGH, CRITICAL) ✅ SNS alerts for high-risk findings ✅ Historical risk tracking in DynamoDB Tiếp theo Chuyển sang 7. Thiết lập Giám sát để thiết lập hệ thống giám sát và alerting.\n"
},
{
	"uri": "//localhost:62814/vi/7-thiet-lap-giam-sat/",
	"title": "7. Thiết lập Giám sát",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thiết lập hệ thống giám sát toàn diện với CloudWatch Alarms, Dashboard và SNS notifications để theo dõi Identity Governance metrics.\nBước 1: Xác minh CloudWatch Metrics 1.1 Kiểm tra Lambda Metrics Mở Amazon CloudWatch console Click Metrics ở sidebar Xác minh metrics từ các Lambda functions: AccessCertificationTrigger PrivilegeAnalyticsEngine RiskAssessmentEngine 1.2 Kiểm tra DynamoDB Metrics Trong CloudWatch Metrics Click AWS/DynamoDB Xác minh metrics cho tables: AccessCertifications RiskAssessments Bước 2: Tạo CloudWatch Alarms 2.1 Tạo Alarm cho Lambda Errors Trong CloudWatch console Click Alarms ở sidebar Click Create alarm Chọn metric: Namespace: AWS/Lambda Metric: Errors Function: AccessCertificationTrigger Cấu hình conditions: Threshold type: Static Condition: Greater than Threshold value: 0 Period: 5 minutes Cấu hình actions: SNS topic: RiskAssessmentAlerts (từ chương 6) Alarm name: Lambda-AccessCertification-Errors Click Create alarm 2.2 Tạo Alarm cho High Risk Users Click Create alarm Chọn Custom metric Tạo custom metric cho high risk users: Namespace: IdentityGovernance Metric: HighRiskUserCount Cấu hình threshold:\nCondition: Greater than 5 Period: 1 hour Click Create alarm\nBước 3: Tạo Comprehensive Dashboard 3.1 Tạo Main Dashboard Trong CloudWatch console Click Dashboards Click Create dashboard Nhập dashboard name: IdentityGovernanceDashboard Click Create dashboard 3.2 Thêm Lambda Metrics Widget Click Add widget Chọn Line chart Cấu hình metrics: Lambda Invocations Lambda Errors Lambda Duration Click Create widget 3.3 Thêm DynamoDB Metrics Widget Click Add widget Chọn Number widget Cấu hình metrics: DynamoDB Item Count DynamoDB Read/Write Capacity Click Create widget 3.4 Thêm Risk Assessment Widget Click Add widget Chọn Pie chart Tạo custom metrics cho risk levels: High Risk Users Medium Risk Users Low Risk Users Click Create widget Bước 4: Thiết lập Custom Metrics Lambda 4.1 Tạo Lambda Function cho Custom Metrics Mở AWS Lambda console Click Create function Nhập thông tin function: Function name: CustomMetricsPublisher Runtime: Python 3.9 4.2 Cấu hình Code cho Custom Metrics Thay thế code mặc định: import json import boto3 from datetime import datetime from boto3.dynamodb.conditions import Key def lambda_handler(event, context): print(\u0026#34;Custom Metrics Publisher Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) try: # Get risk assessment data risk_metrics = get_risk_metrics(dynamodb) # Get certification metrics cert_metrics = get_certification_metrics(dynamodb) # Publish custom metrics publish_metrics(cloudwatch, risk_metrics, cert_metrics) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Custom metrics published successfully\u0026#39;) } except Exception as e: print(f\u0026#39;Error publishing metrics: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def get_risk_metrics(dynamodb): \u0026#34;\u0026#34;\u0026#34;Get risk assessment metrics from DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Get latest user risk assessments response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;User Risk Assessment\u0026#39;} ) risk_levels = {\u0026#39;LOW\u0026#39;: 0, \u0026#39;MEDIUM\u0026#39;: 0, \u0026#39;HIGH\u0026#39;: 0, \u0026#39;CRITICAL\u0026#39;: 0} for item in response[\u0026#39;Items\u0026#39;]: risk_level = item.get(\u0026#39;RiskLevel\u0026#39;, \u0026#39;LOW\u0026#39;) if risk_level in risk_levels: risk_levels[risk_level] += 1 return risk_levels def get_certification_metrics(dynamodb): \u0026#34;\u0026#34;\u0026#34;Get certification metrics from DynamoDB\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) response = table.scan() total_certifications = len(response[\u0026#39;Items\u0026#39;]) recent_certifications = 0 # Count recent certifications (last 30 days) thirty_days_ago = (datetime.now() - timedelta(days=30)).isoformat() for item in response[\u0026#39;Items\u0026#39;]: cert_date = item.get(\u0026#39;CertificationDate\u0026#39;, \u0026#39;\u0026#39;) if cert_date \u0026gt; thirty_days_ago: recent_certifications += 1 return { \u0026#39;total\u0026#39;: total_certifications, \u0026#39;recent\u0026#39;: recent_certifications } def publish_metrics(cloudwatch, risk_metrics, cert_metrics): \u0026#34;\u0026#34;\u0026#34;Publish custom metrics to CloudWatch\u0026#34;\u0026#34;\u0026#34; # Publish risk metrics for risk_level, count in risk_metrics.items(): cloudwatch.put_metric_data( Namespace=\u0026#39;IdentityGovernance\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: f\u0026#39;{risk_level}RiskUserCount\u0026#39;, \u0026#39;Value\u0026#39;: count, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now() } ] ) # Publish certification metrics cloudwatch.put_metric_data( Namespace=\u0026#39;IdentityGovernance\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;TotalCertifications\u0026#39;, \u0026#39;Value\u0026#39;: cert_metrics[\u0026#39;total\u0026#39;], \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now() }, { \u0026#39;MetricName\u0026#39;: \u0026#39;RecentCertifications\u0026#39;, \u0026#39;Value\u0026#39;: cert_metrics[\u0026#39;recent\u0026#39;], \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39;, \u0026#39;Timestamp\u0026#39;: datetime.now() } ] ) print(f\u0026#34;Published metrics: Risk={risk_metrics}, Cert={cert_metrics}\u0026#34;) Click Deploy 4.3 Cấu hình IAM Permissions Thêm permissions cho Lambda: AmazonDynamoDBReadOnlyAccess CloudWatchFullAccess 4.4 Tạo EventBridge Schedule Tạo schedule để chạy CustomMetricsPublisher mỗi 15 phút Cấu hình tương tự như các chương trước Bước 5: Kiểm tra Monitoring System 5.1 Test Custom Metrics Chạy Lambda function CustomMetricsPublisher Kiểm tra CloudWatch Metrics có custom metrics mới 5.2 Test Alarms Tạo test error trong Lambda function Xác minh alarm được trigger Kiểm tra SNS notification 5.3 Xác minh Dashboard Vào IdentityGovernanceDashboard Xác minh tất cả widgets hiển thị data Kiểm tra real-time updates Kết quả Mong đợi Sau khi hoàn thành:\n✅ Comprehensive CloudWatch Dashboard ✅ Automated alarms for critical metrics ✅ Custom metrics for Identity Governance KPIs ✅ SNS notifications for alerts ✅ Real-time monitoring of all components ✅ Historical trend analysis Tiếp theo Chuyển sang 8. Quy trình Vận hành để thiết lập các quy trình vận hành hàng ngày.\n"
},
{
	"uri": "//localhost:62814/vi/8-quy-trinh-van-hanh/",
	"title": "8. Quy trình Vận hành",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thiết lập các quy trình vận hành hàng ngày để duy trì và tối ưu hóa hệ thống Identity Governance, bao gồm automation workflows và operational procedures.\nBước 1: Tạo Operational Dashboard 1.1 Tạo Operations Dashboard Mở Amazon CloudWatch console Click Dashboards Click Create dashboard Nhập dashboard name: IdentityGovernanceOperations Thêm các widgets cho: Daily certification status Risk assessment trends System health metrics Operational KPIs Bước 2: Tạo Daily Operations Lambda 2.1 Tạo Lambda Function Mở AWS Lambda console Click Create function Nhập thông tin function: Function name: DailyOperationsEngine Runtime: Python 3.9 2.2 Cấu hình Code cho Daily Operations Thay thế code mặc định: import json import boto3 from datetime import datetime, timedelta from decimal import Decimal def lambda_handler(event, context): print(\u0026#34;Daily Operations Engine Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) sns = boto3.client(\u0026#39;sns\u0026#39;) ses = boto3.client(\u0026#39;ses\u0026#39;) try: # Perform daily operations operations_report = perform_daily_operations(dynamodb) # Generate daily report daily_report = generate_daily_report(operations_report) # Send notifications send_daily_notifications(sns, ses, daily_report) # Store operations log store_operations_log(dynamodb, operations_report) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: \u0026#39;Daily operations completed\u0026#39;, \u0026#39;report\u0026#39;: daily_report }) } except Exception as e: print(f\u0026#39;Error in daily operations: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def perform_daily_operations(dynamodb): \u0026#34;\u0026#34;\u0026#34;Perform daily operational tasks\u0026#34;\u0026#34;\u0026#34; operations_report = { \u0026#39;date\u0026#39;: datetime.now().strftime(\u0026#39;%Y-%m-%d\u0026#39;), \u0026#39;certification_status\u0026#39;: check_certification_status(dynamodb), \u0026#39;risk_summary\u0026#39;: get_risk_summary(dynamodb), \u0026#39;system_health\u0026#39;: check_system_health(dynamodb), \u0026#39;compliance_status\u0026#39;: check_compliance_status(dynamodb) } return operations_report def check_certification_status(dynamodb): \u0026#34;\u0026#34;\u0026#34;Check certification status for the day\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) # Get certifications from last 24 hours yesterday = (datetime.now() - timedelta(days=1)).isoformat() response = table.scan( FilterExpression=\u0026#39;CertificationDate \u0026gt; :date\u0026#39;, ExpressionAttributeValues={\u0026#39;:date\u0026#39;: yesterday} ) total_certifications = len(response[\u0026#39;Items\u0026#39;]) # Count by status status_counts = {} for item in response[\u0026#39;Items\u0026#39;]: status = item.get(\u0026#39;Status\u0026#39;, \u0026#39;Unknown\u0026#39;) status_counts[status] = status_counts.get(status, 0) + 1 return { \u0026#39;total_certifications\u0026#39;: total_certifications, \u0026#39;status_breakdown\u0026#39;: status_counts, \u0026#39;completion_rate\u0026#39;: calculate_completion_rate(status_counts) } def get_risk_summary(dynamodb): \u0026#34;\u0026#34;\u0026#34;Get current risk summary\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Get latest risk assessments response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;User Risk Assessment\u0026#39;} ) risk_summary = {\u0026#39;LOW\u0026#39;: 0, \u0026#39;MEDIUM\u0026#39;: 0, \u0026#39;HIGH\u0026#39;: 0, \u0026#39;CRITICAL\u0026#39;: 0} total_users = 0 for item in response[\u0026#39;Items\u0026#39;]: risk_level = item.get(\u0026#39;RiskLevel\u0026#39;, \u0026#39;LOW\u0026#39;) if risk_level in risk_summary: risk_summary[risk_level] += 1 total_users += 1 return { \u0026#39;total_users\u0026#39;: total_users, \u0026#39;risk_distribution\u0026#39;: risk_summary, \u0026#39;high_risk_percentage\u0026#39;: ((risk_summary[\u0026#39;HIGH\u0026#39;] + risk_summary[\u0026#39;CRITICAL\u0026#39;]) / max(total_users, 1)) * 100 } def check_system_health(dynamodb): \u0026#34;\u0026#34;\u0026#34;Check overall system health\u0026#34;\u0026#34;\u0026#34; # Check if all components are functioning health_status = { \u0026#39;certification_engine\u0026#39;: check_lambda_health(\u0026#39;AccessCertificationTrigger\u0026#39;), \u0026#39;privilege_analytics\u0026#39;: check_lambda_health(\u0026#39;PrivilegeAnalyticsEngine\u0026#39;), \u0026#39;risk_assessment\u0026#39;: check_lambda_health(\u0026#39;RiskAssessmentEngine\u0026#39;), \u0026#39;custom_metrics\u0026#39;: check_lambda_health(\u0026#39;CustomMetricsPublisher\u0026#39;), \u0026#39;database_health\u0026#39;: check_dynamodb_health(dynamodb) } overall_health = all(health_status.values()) return { \u0026#39;overall_status\u0026#39;: \u0026#39;HEALTHY\u0026#39; if overall_health else \u0026#39;DEGRADED\u0026#39;, \u0026#39;component_status\u0026#39;: health_status } def check_compliance_status(dynamodb): \u0026#34;\u0026#34;\u0026#34;Check compliance status\u0026#34;\u0026#34;\u0026#34; # Calculate compliance metrics cert_table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) risk_table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Get recent certifications thirty_days_ago = (datetime.now() - timedelta(days=30)).isoformat() cert_response = cert_table.scan( FilterExpression=\u0026#39;CertificationDate \u0026gt; :date\u0026#39;, ExpressionAttributeValues={\u0026#39;:date\u0026#39;: thirty_days_ago} ) recent_certifications = len(cert_response[\u0026#39;Items\u0026#39;]) # Get high-risk users risk_response = risk_table.scan( FilterExpression=\u0026#39;AssessmentType = :type AND RiskLevel IN (:high, :critical)\u0026#39;, ExpressionAttributeValues={ \u0026#39;:type\u0026#39;: \u0026#39;User Risk Assessment\u0026#39;, \u0026#39;:high\u0026#39;: \u0026#39;HIGH\u0026#39;, \u0026#39;:critical\u0026#39;: \u0026#39;CRITICAL\u0026#39; } ) high_risk_users = len(risk_response[\u0026#39;Items\u0026#39;]) # Calculate compliance score compliance_score = calculate_compliance_score(recent_certifications, high_risk_users) return { \u0026#39;compliance_score\u0026#39;: compliance_score, \u0026#39;recent_certifications\u0026#39;: recent_certifications, \u0026#39;high_risk_users\u0026#39;: high_risk_users, \u0026#39;status\u0026#39;: \u0026#39;COMPLIANT\u0026#39; if compliance_score \u0026gt;= 80 else \u0026#39;NON_COMPLIANT\u0026#39; } def calculate_completion_rate(status_counts): \u0026#34;\u0026#34;\u0026#34;Calculate certification completion rate\u0026#34;\u0026#34;\u0026#34; total = sum(status_counts.values()) completed = status_counts.get(\u0026#39;Completed\u0026#39;, 0) + status_counts.get(\u0026#39;Approved\u0026#39;, 0) return (completed / max(total, 1)) * 100 def check_lambda_health(function_name): \u0026#34;\u0026#34;\u0026#34;Check Lambda function health (simplified)\u0026#34;\u0026#34;\u0026#34; # In real implementation, check CloudWatch metrics return True def check_dynamodb_health(dynamodb): \u0026#34;\u0026#34;\u0026#34;Check DynamoDB health\u0026#34;\u0026#34;\u0026#34; try: # Simple health check by listing tables tables = [\u0026#39;AccessCertifications\u0026#39;, \u0026#39;RiskAssessments\u0026#39;] for table_name in tables: table = dynamodb.Table(table_name) table.table_status # This will raise exception if table doesn\u0026#39;t exist return True except Exception: return False def calculate_compliance_score(recent_certs, high_risk_users): \u0026#34;\u0026#34;\u0026#34;Calculate overall compliance score\u0026#34;\u0026#34;\u0026#34; base_score = 100 # Deduct points for lack of recent certifications if recent_certs \u0026lt; 10: base_score -= 20 elif recent_certs \u0026lt; 20: base_score -= 10 # Deduct points for high-risk users if high_risk_users \u0026gt; 10: base_score -= 30 elif high_risk_users \u0026gt; 5: base_score -= 15 elif high_risk_users \u0026gt; 0: base_score -= 5 return max(base_score, 0) def generate_daily_report(operations_report): \u0026#34;\u0026#34;\u0026#34;Generate daily operations report\u0026#34;\u0026#34;\u0026#34; report = { \u0026#39;date\u0026#39;: operations_report[\u0026#39;date\u0026#39;], \u0026#39;summary\u0026#39;: { \u0026#39;total_certifications\u0026#39;: operations_report[\u0026#39;certification_status\u0026#39;][\u0026#39;total_certifications\u0026#39;], \u0026#39;completion_rate\u0026#39;: round(operations_report[\u0026#39;certification_status\u0026#39;][\u0026#39;completion_rate\u0026#39;], 2), \u0026#39;high_risk_users\u0026#39;: operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;HIGH\u0026#39;] + operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;CRITICAL\u0026#39;], \u0026#39;system_status\u0026#39;: operations_report[\u0026#39;system_health\u0026#39;][\u0026#39;overall_status\u0026#39;], \u0026#39;compliance_score\u0026#39;: operations_report[\u0026#39;compliance_status\u0026#39;][\u0026#39;compliance_score\u0026#39;] }, \u0026#39;recommendations\u0026#39;: generate_recommendations(operations_report) } return report def generate_recommendations(operations_report): \u0026#34;\u0026#34;\u0026#34;Generate operational recommendations\u0026#34;\u0026#34;\u0026#34; recommendations = [] # Check completion rate completion_rate = operations_report[\u0026#39;certification_status\u0026#39;][\u0026#39;completion_rate\u0026#39;] if completion_rate \u0026lt; 80: recommendations.append(\u0026#34;Low certification completion rate. Consider sending reminder notifications.\u0026#34;) # Check high-risk users high_risk_count = (operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;HIGH\u0026#39;] + operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;CRITICAL\u0026#39;]) if high_risk_count \u0026gt; 5: recommendations.append(f\u0026#34;High number of high-risk users ({high_risk_count}). Review and remediate immediately.\u0026#34;) # Check system health if operations_report[\u0026#39;system_health\u0026#39;][\u0026#39;overall_status\u0026#39;] != \u0026#39;HEALTHY\u0026#39;: recommendations.append(\u0026#34;System health degraded. Check component status and resolve issues.\u0026#34;) # Check compliance if operations_report[\u0026#39;compliance_status\u0026#39;][\u0026#39;status\u0026#39;] != \u0026#39;COMPLIANT\u0026#39;: recommendations.append(\u0026#34;Compliance status is non-compliant. Review certification and risk management processes.\u0026#34;) return recommendations def send_daily_notifications(sns, ses, daily_report): \u0026#34;\u0026#34;\u0026#34;Send daily notifications\u0026#34;\u0026#34;\u0026#34; # Prepare notification message message = format_daily_report_message(daily_report) # Send SNS notification try: sns.publish( TopicArn=\u0026#39;arn:aws:sns:region:account:RiskAssessmentAlerts\u0026#39;, # Update with actual ARN Subject=\u0026#39;Daily Identity Governance Report\u0026#39;, Message=message ) except Exception as e: print(f\u0026#39;Error sending SNS notification: {str(e)}\u0026#39;) def format_daily_report_message(report): \u0026#34;\u0026#34;\u0026#34;Format daily report message\u0026#34;\u0026#34;\u0026#34; message = f\u0026#34;\u0026#34;\u0026#34; Daily Identity Governance Report - {report[\u0026#39;date\u0026#39;]} SUMMARY: - Total Certifications: {report[\u0026#39;summary\u0026#39;][\u0026#39;total_certifications\u0026#39;]} - Completion Rate: {report[\u0026#39;summary\u0026#39;][\u0026#39;completion_rate\u0026#39;]}% - High Risk Users: {report[\u0026#39;summary\u0026#39;][\u0026#39;high_risk_users\u0026#39;]} - System Status: {report[\u0026#39;summary\u0026#39;][\u0026#39;system_status\u0026#39;]} - Compliance Score: {report[\u0026#39;summary\u0026#39;][\u0026#39;compliance_score\u0026#39;]} RECOMMENDATIONS: \u0026#34;\u0026#34;\u0026#34; for rec in report[\u0026#39;recommendations\u0026#39;]: message += f\u0026#34;- {rec}\\n\u0026#34; return message def store_operations_log(dynamodb, operations_report): \u0026#34;\u0026#34;\u0026#34;Store daily operations log\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) table.put_item( Item={ \u0026#39;AssessmentId\u0026#39;: f\u0026#34;daily-ops-{operations_report[\u0026#39;date\u0026#39;]}\u0026#34;, \u0026#39;AssessmentType\u0026#39;: \u0026#39;Daily Operations Report\u0026#39;, \u0026#39;Date\u0026#39;: operations_report[\u0026#39;date\u0026#39;], \u0026#39;CertificationCount\u0026#39;: operations_report[\u0026#39;certification_status\u0026#39;][\u0026#39;total_certifications\u0026#39;], \u0026#39;CompletionRate\u0026#39;: Decimal(str(operations_report[\u0026#39;certification_status\u0026#39;][\u0026#39;completion_rate\u0026#39;])), \u0026#39;HighRiskUsers\u0026#39;: operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;HIGH\u0026#39;] + operations_report[\u0026#39;risk_summary\u0026#39;][\u0026#39;risk_distribution\u0026#39;][\u0026#39;CRITICAL\u0026#39;], \u0026#39;SystemStatus\u0026#39;: operations_report[\u0026#39;system_health\u0026#39;][\u0026#39;overall_status\u0026#39;], \u0026#39;ComplianceScore\u0026#39;: operations_report[\u0026#39;compliance_status\u0026#39;][\u0026#39;compliance_score\u0026#39;], \u0026#39;ComplianceStatus\u0026#39;: operations_report[\u0026#39;compliance_status\u0026#39;][\u0026#39;status\u0026#39;] } ) Click Deploy 2.3 Cấu hình IAM Permissions Thêm permissions cho Lambda: AmazonDynamoDBFullAccess AmazonSNSFullAccess AmazonSESFullAccess Bước 3: Thiết lập Automated Workflows 3.1 Tạo EventBridge Schedule cho Daily Operations Tạo schedule chạy DailyOperationsEngine mỗi ngày lúc 8:00 AM Cấu hình tương tự các chương trước 3.2 Tạo Weekly Summary Schedule Tạo thêm schedule chạy weekly summary mỗi thứ 2 Cấu hình để tạo báo cáo tuần Bước 4: Tạo Operational Runbooks 4.1 Tạo S3 Bucket cho Documentation Mở Amazon S3 console Tạo bucket: identity-governance-runbooks Upload operational procedures 4.2 Tạo Systems Manager Documents Mở AWS Systems Manager console Click Documents Tạo automation documents cho common tasks Bước 5: Kiểm tra Operational Workflows 5.1 Test Daily Operations Chạy Lambda function DailyOperationsEngine Xác minh daily report được tạo Kiểm tra SNS notifications 5.2 Xác minh Operations Dashboard Kiểm tra IdentityGovernanceOperations dashboard Xác minh tất cả metrics hiển thị đúng Test real-time updates 5.3 Test Automation Workflows Xác minh scheduled executions Kiểm tra error handling Test notification delivery Kết quả Mong đợi Sau khi hoàn thành:\n✅ Automated daily operations workflows ✅ Comprehensive operational dashboard ✅ Daily and weekly reporting automation ✅ Operational runbooks and procedures ✅ Health monitoring and alerting ✅ Compliance tracking and reporting Tiếp theo Chuyển sang 9. Quy trình Kiểm toán để thiết lập các quy trình kiểm toán và compliance.\n"
},
{
	"uri": "//localhost:62814/vi/9-quy-trinh-kiem-toan/",
	"title": "9. Quy trình Kiểm toán",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thiết lập quy trình kiểm toán toàn diện để đảm bảo tuân thủ các tiêu chuẩn SOX, SOC2, ISO27001 và tạo audit trails cho Identity Governance system.\nBước 1: Thiết lập Audit Data Collection 1.1 Xác minh CloudTrail Audit Logs Mở Amazon CloudTrail console Xác minh trail IdentityGovernanceTrail đang ghi đầy đủ audit events Kiểm tra log file validation được bật 1.2 Cấu hình CloudTrail Insights Trong CloudTrail console Chọn trail IdentityGovernanceTrail Click Edit Bật CloudTrail Insights cho unusual activity patterns Click Save changes Bước 2: Tạo Audit Report Generator 2.1 Tạo Lambda Function Mở AWS Lambda console Click Create function Nhập thông tin function: Function name: AuditReportGenerator Runtime: Python 3.9 2.2 Cấu hình Code cho Audit Reports Thay thế code mặc định: import json import boto3 import csv from datetime import datetime, timedelta from io import StringIO def lambda_handler(event, context): print(\u0026#34;Audit Report Generator Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) s3 = boto3.client(\u0026#39;s3\u0026#39;) cloudtrail = boto3.client(\u0026#39;cloudtrail\u0026#39;) try: # Generate different types of audit reports report_type = event.get(\u0026#39;report_type\u0026#39;, \u0026#39;comprehensive\u0026#39;) if report_type == \u0026#39;access_certification\u0026#39;: report = generate_access_certification_report(dynamodb) elif report_type == \u0026#39;privilege_usage\u0026#39;: report = generate_privilege_usage_report(dynamodb, cloudtrail) elif report_type == \u0026#39;risk_assessment\u0026#39;: report = generate_risk_assessment_report(dynamodb) elif report_type == \u0026#39;compliance\u0026#39;: report = generate_compliance_report(dynamodb, cloudtrail) else: report = generate_comprehensive_audit_report(dynamodb, cloudtrail) # Store report in S3 report_url = store_audit_report(s3, report, report_type) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;message\u0026#39;: f\u0026#39;{report_type} audit report generated successfully\u0026#39;, \u0026#39;report_url\u0026#39;: report_url, \u0026#39;report_date\u0026#39;: datetime.now().isoformat() }) } except Exception as e: print(f\u0026#39;Error generating audit report: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def generate_access_certification_report(dynamodb): \u0026#34;\u0026#34;\u0026#34;Generate access certification audit report\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) response = table.scan() certifications = response[\u0026#39;Items\u0026#39;] # Analyze certification data report = { \u0026#39;report_type\u0026#39;: \u0026#39;Access Certification Audit\u0026#39;, \u0026#39;generated_date\u0026#39;: datetime.now().isoformat(), \u0026#39;summary\u0026#39;: { \u0026#39;total_certifications\u0026#39;: len(certifications), \u0026#39;completed_certifications\u0026#39;: len([c for c in certifications if c.get(\u0026#39;Status\u0026#39;) in [\u0026#39;Completed\u0026#39;, \u0026#39;Approved\u0026#39;]]), \u0026#39;pending_certifications\u0026#39;: len([c for c in certifications if c.get(\u0026#39;Status\u0026#39;) == \u0026#39;Pending\u0026#39;]), \u0026#39;overdue_certifications\u0026#39;: count_overdue_certifications(certifications) }, \u0026#39;details\u0026#39;: [] } # Add detailed certification records for cert in certifications: report[\u0026#39;details\u0026#39;].append({ \u0026#39;user_id\u0026#39;: cert.get(\u0026#39;UserId\u0026#39;), \u0026#39;certification_date\u0026#39;: cert.get(\u0026#39;CertificationDate\u0026#39;), \u0026#39;status\u0026#39;: cert.get(\u0026#39;Status\u0026#39;), \u0026#39;type\u0026#39;: cert.get(\u0026#39;Type\u0026#39;), \u0026#39;days_since_certification\u0026#39;: calculate_days_since(cert.get(\u0026#39;CertificationDate\u0026#39;)) }) return report def generate_privilege_usage_report(dynamodb, cloudtrail): \u0026#34;\u0026#34;\u0026#34;Generate privilege usage audit report\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Get privilege analysis data response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;Privilege Analysis\u0026#39;} ) privilege_events = response[\u0026#39;Items\u0026#39;] # Analyze privilege usage patterns report = { \u0026#39;report_type\u0026#39;: \u0026#39;Privilege Usage Audit\u0026#39;, \u0026#39;generated_date\u0026#39;: datetime.now().isoformat(), \u0026#39;summary\u0026#39;: { \u0026#39;total_privilege_events\u0026#39;: len(privilege_events), \u0026#39;high_risk_events\u0026#39;: len([e for e in privilege_events if float(e.get(\u0026#39;RiskScore\u0026#39;, 0)) \u0026gt;= 8]), \u0026#39;unique_users\u0026#39;: len(set([e.get(\u0026#39;UserIdentity\u0026#39;, \u0026#39;\u0026#39;) for e in privilege_events])), \u0026#39;event_types\u0026#39;: count_event_types(privilege_events) }, \u0026#39;high_risk_activities\u0026#39;: [] } # Add high-risk privilege activities for event in privilege_events: if float(event.get(\u0026#39;RiskScore\u0026#39;, 0)) \u0026gt;= 8: report[\u0026#39;high_risk_activities\u0026#39;].append({ \u0026#39;event_time\u0026#39;: event.get(\u0026#39;EventTime\u0026#39;), \u0026#39;event_name\u0026#39;: event.get(\u0026#39;EventName\u0026#39;), \u0026#39;user_identity\u0026#39;: event.get(\u0026#39;UserIdentity\u0026#39;), \u0026#39;source_ip\u0026#39;: event.get(\u0026#39;SourceIP\u0026#39;), \u0026#39;risk_score\u0026#39;: event.get(\u0026#39;RiskScore\u0026#39;) }) return report def generate_risk_assessment_report(dynamodb): \u0026#34;\u0026#34;\u0026#34;Generate risk assessment audit report\u0026#34;\u0026#34;\u0026#34; table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) # Get user risk assessments response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;User Risk Assessment\u0026#39;} ) risk_assessments = response[\u0026#39;Items\u0026#39;] # Analyze risk distribution risk_distribution = {\u0026#39;LOW\u0026#39;: 0, \u0026#39;MEDIUM\u0026#39;: 0, \u0026#39;HIGH\u0026#39;: 0, \u0026#39;CRITICAL\u0026#39;: 0} for assessment in risk_assessments: risk_level = assessment.get(\u0026#39;RiskLevel\u0026#39;, \u0026#39;LOW\u0026#39;) if risk_level in risk_distribution: risk_distribution[risk_level] += 1 report = { \u0026#39;report_type\u0026#39;: \u0026#39;Risk Assessment Audit\u0026#39;, \u0026#39;generated_date\u0026#39;: datetime.now().isoformat(), \u0026#39;summary\u0026#39;: { \u0026#39;total_users_assessed\u0026#39;: len(risk_assessments), \u0026#39;risk_distribution\u0026#39;: risk_distribution, \u0026#39;high_risk_percentage\u0026#39;: ((risk_distribution[\u0026#39;HIGH\u0026#39;] + risk_distribution[\u0026#39;CRITICAL\u0026#39;]) / max(len(risk_assessments), 1)) * 100 }, \u0026#39;high_risk_users\u0026#39;: [] } # Add high-risk users for assessment in risk_assessments: if assessment.get(\u0026#39;RiskLevel\u0026#39;) in [\u0026#39;HIGH\u0026#39;, \u0026#39;CRITICAL\u0026#39;]: report[\u0026#39;high_risk_users\u0026#39;].append({ \u0026#39;user_name\u0026#39;: assessment.get(\u0026#39;UserName\u0026#39;), \u0026#39;risk_score\u0026#39;: float(assessment.get(\u0026#39;RiskScore\u0026#39;, 0)), \u0026#39;risk_level\u0026#39;: assessment.get(\u0026#39;RiskLevel\u0026#39;), \u0026#39;assessment_date\u0026#39;: assessment.get(\u0026#39;AssessmentDate\u0026#39;), \u0026#39;risk_factors\u0026#39;: { \u0026#39;certification\u0026#39;: float(assessment.get(\u0026#39;CertificationRisk\u0026#39;, 0)), \u0026#39;privilege\u0026#39;: float(assessment.get(\u0026#39;PrivilegeRisk\u0026#39;, 0)), \u0026#39;security\u0026#39;: float(assessment.get(\u0026#39;SecurityRisk\u0026#39;, 0)), \u0026#39;access\u0026#39;: float(assessment.get(\u0026#39;AccessRisk\u0026#39;, 0)) } }) return report def generate_compliance_report(dynamodb, cloudtrail): \u0026#34;\u0026#34;\u0026#34;Generate compliance audit report\u0026#34;\u0026#34;\u0026#34; # Get operational data ops_table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) ops_response = ops_table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;Daily Operations Report\u0026#39;} ) ops_reports = ops_response[\u0026#39;Items\u0026#39;] # Calculate compliance metrics if ops_reports: latest_ops = max(ops_reports, key=lambda x: x.get(\u0026#39;Date\u0026#39;, \u0026#39;\u0026#39;)) compliance_score = float(latest_ops.get(\u0026#39;ComplianceScore\u0026#39;, 0)) compliance_status = latest_ops.get(\u0026#39;ComplianceStatus\u0026#39;, \u0026#39;UNKNOWN\u0026#39;) else: compliance_score = 0 compliance_status = \u0026#39;NO_DATA\u0026#39; report = { \u0026#39;report_type\u0026#39;: \u0026#39;Compliance Audit\u0026#39;, \u0026#39;generated_date\u0026#39;: datetime.now().isoformat(), \u0026#39;compliance_frameworks\u0026#39;: { \u0026#39;SOX\u0026#39;: assess_sox_compliance(dynamodb), \u0026#39;SOC2\u0026#39;: assess_soc2_compliance(dynamodb), \u0026#39;ISO27001\u0026#39;: assess_iso27001_compliance(dynamodb) }, \u0026#39;overall_compliance\u0026#39;: { \u0026#39;score\u0026#39;: compliance_score, \u0026#39;status\u0026#39;: compliance_status, \u0026#39;last_assessment\u0026#39;: latest_ops.get(\u0026#39;Date\u0026#39;, \u0026#39;N/A\u0026#39;) if ops_reports else \u0026#39;N/A\u0026#39; }, \u0026#39;compliance_gaps\u0026#39;: identify_compliance_gaps(dynamodb) } return report def generate_comprehensive_audit_report(dynamodb, cloudtrail): \u0026#34;\u0026#34;\u0026#34;Generate comprehensive audit report\u0026#34;\u0026#34;\u0026#34; # Combine all report types access_report = generate_access_certification_report(dynamodb) privilege_report = generate_privilege_usage_report(dynamodb, cloudtrail) risk_report = generate_risk_assessment_report(dynamodb) compliance_report = generate_compliance_report(dynamodb, cloudtrail) comprehensive_report = { \u0026#39;report_type\u0026#39;: \u0026#39;Comprehensive Identity Governance Audit\u0026#39;, \u0026#39;generated_date\u0026#39;: datetime.now().isoformat(), \u0026#39;executive_summary\u0026#39;: generate_executive_summary(access_report, privilege_report, risk_report, compliance_report), \u0026#39;access_certification\u0026#39;: access_report, \u0026#39;privilege_usage\u0026#39;: privilege_report, \u0026#39;risk_assessment\u0026#39;: risk_report, \u0026#39;compliance\u0026#39;: compliance_report } return comprehensive_report def count_overdue_certifications(certifications): \u0026#34;\u0026#34;\u0026#34;Count overdue certifications\u0026#34;\u0026#34;\u0026#34; overdue_count = 0 ninety_days_ago = datetime.now() - timedelta(days=90) for cert in certifications: cert_date_str = cert.get(\u0026#39;CertificationDate\u0026#39;, \u0026#39;\u0026#39;) if cert_date_str: try: cert_date = datetime.fromisoformat(cert_date_str.replace(\u0026#39;Z\u0026#39;, \u0026#39;+00:00\u0026#39;)) if cert_date.replace(tzinfo=None) \u0026lt; ninety_days_ago: overdue_count += 1 except: pass return overdue_count def calculate_days_since(date_str): \u0026#34;\u0026#34;\u0026#34;Calculate days since a given date\u0026#34;\u0026#34;\u0026#34; if not date_str: return None try: date_obj = datetime.fromisoformat(date_str.replace(\u0026#39;Z\u0026#39;, \u0026#39;+00:00\u0026#39;)) return (datetime.now(date_obj.tzinfo) - date_obj).days except: return None def count_event_types(events): \u0026#34;\u0026#34;\u0026#34;Count different types of privilege events\u0026#34;\u0026#34;\u0026#34; event_counts = {} for event in events: event_name = event.get(\u0026#39;EventName\u0026#39;, \u0026#39;Unknown\u0026#39;) event_counts[event_name] = event_counts.get(event_name, 0) + 1 return event_counts def assess_sox_compliance(dynamodb): \u0026#34;\u0026#34;\u0026#34;Assess SOX compliance\u0026#34;\u0026#34;\u0026#34; # Simplified SOX assessment return { \u0026#39;status\u0026#39;: \u0026#39;COMPLIANT\u0026#39;, \u0026#39;score\u0026#39;: 85, \u0026#39;requirements_met\u0026#39;: [ \u0026#39;Access controls documented\u0026#39;, \u0026#39;Regular access reviews conducted\u0026#39;, \u0026#39;Audit trails maintained\u0026#39; ], \u0026#39;gaps\u0026#39;: [ \u0026#39;Quarterly management attestation needed\u0026#39; ] } def assess_soc2_compliance(dynamodb): \u0026#34;\u0026#34;\u0026#34;Assess SOC2 compliance\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;status\u0026#39;: \u0026#39;MOSTLY_COMPLIANT\u0026#39;, \u0026#39;score\u0026#39;: 78, \u0026#39;requirements_met\u0026#39;: [ \u0026#39;Access monitoring implemented\u0026#39;, \u0026#39;Risk assessments performed\u0026#39;, \u0026#39;Security controls documented\u0026#39; ], \u0026#39;gaps\u0026#39;: [ \u0026#39;Vendor access controls need enhancement\u0026#39;, \u0026#39;Incident response procedures need update\u0026#39; ] } def assess_iso27001_compliance(dynamodb): \u0026#34;\u0026#34;\u0026#34;Assess ISO27001 compliance\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;status\u0026#39;: \u0026#39;COMPLIANT\u0026#39;, \u0026#39;score\u0026#39;: 82, \u0026#39;requirements_met\u0026#39;: [ \u0026#39;Information security policy established\u0026#39;, \u0026#39;Access control procedures implemented\u0026#39;, \u0026#39;Regular security assessments conducted\u0026#39; ], \u0026#39;gaps\u0026#39;: [ \u0026#39;Business continuity plan needs review\u0026#39; ] } def identify_compliance_gaps(dynamodb): \u0026#34;\u0026#34;\u0026#34;Identify compliance gaps\u0026#34;\u0026#34;\u0026#34; return [ { \u0026#39;gap\u0026#39;: \u0026#39;Incomplete access certifications\u0026#39;, \u0026#39;severity\u0026#39;: \u0026#39;HIGH\u0026#39;, \u0026#39;recommendation\u0026#39;: \u0026#39;Implement automated reminders for pending certifications\u0026#39; }, { \u0026#39;gap\u0026#39;: \u0026#39;High-risk users not reviewed\u0026#39;, \u0026#39;severity\u0026#39;: \u0026#39;MEDIUM\u0026#39;, \u0026#39;recommendation\u0026#39;: \u0026#39;Establish monthly review process for high-risk users\u0026#39; } ] def generate_executive_summary(access_report, privilege_report, risk_report, compliance_report): \u0026#34;\u0026#34;\u0026#34;Generate executive summary\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;key_metrics\u0026#39;: { \u0026#39;total_certifications\u0026#39;: access_report[\u0026#39;summary\u0026#39;][\u0026#39;total_certifications\u0026#39;], \u0026#39;completion_rate\u0026#39;: (access_report[\u0026#39;summary\u0026#39;][\u0026#39;completed_certifications\u0026#39;] / max(access_report[\u0026#39;summary\u0026#39;][\u0026#39;total_certifications\u0026#39;], 1)) * 100, \u0026#39;high_risk_users\u0026#39;: len(risk_report[\u0026#39;high_risk_users\u0026#39;]), \u0026#39;overall_compliance_score\u0026#39;: compliance_report[\u0026#39;overall_compliance\u0026#39;][\u0026#39;score\u0026#39;] }, \u0026#39;key_findings\u0026#39;: [ f\u0026#34;Access certification completion rate: {((access_report[\u0026#39;summary\u0026#39;][\u0026#39;completed_certifications\u0026#39;] / max(access_report[\u0026#39;summary\u0026#39;][\u0026#39;total_certifications\u0026#39;], 1)) * 100):.1f}%\u0026#34;, f\u0026#34;High-risk privilege events detected: {privilege_report[\u0026#39;summary\u0026#39;][\u0026#39;high_risk_events\u0026#39;]}\u0026#34;, f\u0026#34;Users requiring immediate attention: {len(risk_report[\u0026#39;high_risk_users\u0026#39;])}\u0026#34;, f\u0026#34;Overall compliance status: {compliance_report[\u0026#39;overall_compliance\u0026#39;][\u0026#39;status\u0026#39;]}\u0026#34; ], \u0026#39;recommendations\u0026#39;: [ \u0026#39;Increase certification completion rate through automated reminders\u0026#39;, \u0026#39;Review and remediate high-risk privilege usage patterns\u0026#39;, \u0026#39;Implement additional controls for high-risk users\u0026#39;, \u0026#39;Address identified compliance gaps\u0026#39; ] } def store_audit_report(s3, report, report_type): \u0026#34;\u0026#34;\u0026#34;Store audit report in S3\u0026#34;\u0026#34;\u0026#34; bucket_name = \u0026#39;identity-governance-reports\u0026#39; # From chapter 2 timestamp = datetime.now().strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;) key = f\u0026#39;audit-reports/{report_type}_{timestamp}.json\u0026#39; try: s3.put_object( Bucket=bucket_name, Key=key, Body=json.dumps(report, indent=2, default=str), ContentType=\u0026#39;application/json\u0026#39; ) return f\u0026#39;s3://{bucket_name}/{key}\u0026#39; except Exception as e: print(f\u0026#39;Error storing report in S3: {str(e)}\u0026#39;) return None Click Deploy 2.3 Cấu hình IAM Permissions Thêm permissions cho Lambda: AmazonDynamoDBReadOnlyAccess AmazonS3FullAccess CloudTrailReadOnlyAccess Bước 3: Thiết lập Automated Audit Schedules 3.1 Tạo Monthly Audit Schedule Mở Amazon EventBridge console Tạo schedule chạy audit reports hàng tháng Cấu hình để tạo comprehensive audit report 3.2 Tạo Quarterly Compliance Schedule Tạo schedule chạy compliance reports hàng quý Cấu hình notification cho management Bước 4: Thiết lập Audit Trail Monitoring 4.1 Tạo CloudWatch Alarms cho Audit Events Mở Amazon CloudWatch console Tạo alarms cho critical audit events: Unauthorized access attempts Privilege escalation events Failed authentication events 4.2 Cấu hình Log Insights Queries Trong CloudWatch console Click Logs Insights Tạo saved queries cho audit analysis Bước 5: Kiểm tra Audit System 5.1 Test Audit Report Generation Chạy Lambda function AuditReportGenerator Test với các report types khác nhau Xác minh reports được lưu trong S3 5.2 Xác minh Audit Trail Completeness Kiểm tra CloudTrail logs có đầy đủ events Xác minh log file validation Test audit trail queries 5.3 Test Compliance Reporting Generate compliance reports Xác minh compliance scores Review compliance gaps identification Kết quả Mong đợi Sau khi hoàn thành:\n✅ Comprehensive audit trail system ✅ Automated audit report generation ✅ SOX, SOC2, ISO27001 compliance reporting ✅ Monthly and quarterly audit schedules ✅ Real-time audit event monitoring ✅ Compliance gap identification and remediation Tiếp theo Chuyển sang 10. Xác thực Tuân thủ để thực hiện validation cuối cùng và compliance verification.\n"
},
{
	"uri": "//localhost:62814/vi/10-xac-thuc-tuan-thu/",
	"title": "10. Xác thực Tuân thủ",
	"tags": [],
	"description": "",
	"content": "Mục tiêu Thực hiện validation cuối cùng cho toàn bộ hệ thống Identity Governance, xác minh tuân thủ các tiêu chuẩn và chuẩn bị cho production deployment.\nBước 1: Comprehensive System Validation 1.1 Kiểm tra Tất cả Components Mở AWS Lambda console Xác minh tất cả Lambda functions đang hoạt động: AccessCertificationTrigger PrivilegeAnalyticsEngine RiskAssessmentEngine CustomMetricsPublisher DailyOperationsEngine AuditReportGenerator 1.2 Xác minh Data Flow Kiểm tra DynamoDB tables có dữ liệu: AccessCertifications RiskAssessments Xác minh S3 buckets có audit reports: identity-governance-analytics identity-governance-reports CloudTrail logs bucket Bước 2: End-to-End Testing 2.1 Tạo Lambda Function cho E2E Testing Mở AWS Lambda console Click Create function Nhập thông tin function: Function name: E2EValidationTest Runtime: Python 3.9 2.2 Cấu hình E2E Test Code Thay thế code mặc định: import json import boto3 from datetime import datetime, timedelta def lambda_handler(event, context): print(\u0026#34;E2E Validation Test Started\u0026#34;) # Initialize AWS clients dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) s3 = boto3.client(\u0026#39;s3\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) test_results = { \u0026#39;test_date\u0026#39;: datetime.now().isoformat(), \u0026#39;tests\u0026#39;: [] } try: # Test 1: Data Integrity test_results[\u0026#39;tests\u0026#39;].append(test_data_integrity(dynamodb)) # Test 2: Lambda Functions test_results[\u0026#39;tests\u0026#39;].append(test_lambda_functions(lambda_client)) # Test 3: Audit Reports test_results[\u0026#39;tests\u0026#39;].append(test_audit_reports(s3)) # Test 4: Monitoring test_results[\u0026#39;tests\u0026#39;].append(test_monitoring_system(cloudwatch)) # Test 5: Compliance test_results[\u0026#39;tests\u0026#39;].append(test_compliance_validation(dynamodb)) # Calculate overall test result passed_tests = sum(1 for test in test_results[\u0026#39;tests\u0026#39;] if test[\u0026#39;status\u0026#39;] == \u0026#39;PASS\u0026#39;) total_tests = len(test_results[\u0026#39;tests\u0026#39;]) test_results[\u0026#39;summary\u0026#39;] = { \u0026#39;total_tests\u0026#39;: total_tests, \u0026#39;passed_tests\u0026#39;: passed_tests, \u0026#39;failed_tests\u0026#39;: total_tests - passed_tests, \u0026#39;success_rate\u0026#39;: (passed_tests / total_tests) * 100, \u0026#39;overall_status\u0026#39;: \u0026#39;PASS\u0026#39; if passed_tests == total_tests else \u0026#39;FAIL\u0026#39; } return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(test_results, default=str) } except Exception as e: print(f\u0026#39;Error in E2E validation: {str(e)}\u0026#39;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(f\u0026#39;Error: {str(e)}\u0026#39;) } def test_data_integrity(dynamodb): \u0026#34;\u0026#34;\u0026#34;Test data integrity across DynamoDB tables\u0026#34;\u0026#34;\u0026#34; test_result = { \u0026#39;test_name\u0026#39;: \u0026#39;Data Integrity Test\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39;, \u0026#39;details\u0026#39;: [], \u0026#39;errors\u0026#39;: [] } try: # Test AccessCertifications table cert_table = dynamodb.Table(\u0026#39;AccessCertifications\u0026#39;) cert_response = cert_table.scan(Limit=10) if cert_response[\u0026#39;Items\u0026#39;]: test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;AccessCertifications table: {len(cert_response[\u0026#39;Items\u0026#39;])} records found\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;AccessCertifications table is empty\u0026#34;) # Test RiskAssessments table risk_table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) risk_response = risk_table.scan(Limit=10) if risk_response[\u0026#39;Items\u0026#39;]: test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;RiskAssessments table: {len(risk_response[\u0026#39;Items\u0026#39;])} records found\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;RiskAssessments table is empty\u0026#34;) except Exception as e: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;Data integrity test failed: {str(e)}\u0026#34;) return test_result def test_lambda_functions(lambda_client): \u0026#34;\u0026#34;\u0026#34;Test all Lambda functions are working\u0026#34;\u0026#34;\u0026#34; test_result = { \u0026#39;test_name\u0026#39;: \u0026#39;Lambda Functions Test\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39;, \u0026#39;details\u0026#39;: [], \u0026#39;errors\u0026#39;: [] } functions_to_test = [ \u0026#39;AccessCertificationTrigger\u0026#39;, \u0026#39;PrivilegeAnalyticsEngine\u0026#39;, \u0026#39;RiskAssessmentEngine\u0026#39;, \u0026#39;CustomMetricsPublisher\u0026#39;, \u0026#39;DailyOperationsEngine\u0026#39;, \u0026#39;AuditReportGenerator\u0026#39; ] for function_name in functions_to_test: try: # Get function configuration response = lambda_client.get_function(FunctionName=function_name) if response[\u0026#39;Configuration\u0026#39;][\u0026#39;State\u0026#39;] == \u0026#39;Active\u0026#39;: test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;{function_name}: Active\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;{function_name}: Not active\u0026#34;) except lambda_client.exceptions.ResourceNotFoundException: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;{function_name}: Function not found\u0026#34;) except Exception as e: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;{function_name}: Error - {str(e)}\u0026#34;) return test_result def test_audit_reports(s3): \u0026#34;\u0026#34;\u0026#34;Test audit reports are being generated\u0026#34;\u0026#34;\u0026#34; test_result = { \u0026#39;test_name\u0026#39;: \u0026#39;Audit Reports Test\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39;, \u0026#39;details\u0026#39;: [], \u0026#39;errors\u0026#39;: [] } try: bucket_name = \u0026#39;identity-governance-reports\u0026#39; # List objects in audit-reports prefix response = s3.list_objects_v2( Bucket=bucket_name, Prefix=\u0026#39;audit-reports/\u0026#39;, MaxKeys=10 ) if \u0026#39;Contents\u0026#39; in response and response[\u0026#39;Contents\u0026#39;]: test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;Found {len(response[\u0026#39;Contents\u0026#39;])} audit reports\u0026#34;) # Check if reports are recent (within last 7 days) recent_reports = 0 seven_days_ago = datetime.now() - timedelta(days=7) for obj in response[\u0026#39;Contents\u0026#39;]: if obj[\u0026#39;LastModified\u0026#39;].replace(tzinfo=None) \u0026gt; seven_days_ago: recent_reports += 1 test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;Recent reports (last 7 days): {recent_reports}\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;No audit reports found\u0026#34;) except Exception as e: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;Audit reports test failed: {str(e)}\u0026#34;) return test_result def test_monitoring_system(cloudwatch): \u0026#34;\u0026#34;\u0026#34;Test monitoring system is working\u0026#34;\u0026#34;\u0026#34; test_result = { \u0026#39;test_name\u0026#39;: \u0026#39;Monitoring System Test\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39;, \u0026#39;details\u0026#39;: [], \u0026#39;errors\u0026#39;: [] } try: # Check for custom metrics response = cloudwatch.list_metrics( Namespace=\u0026#39;IdentityGovernance\u0026#39; ) if response[\u0026#39;Metrics\u0026#39;]: test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;Found {len(response[\u0026#39;Metrics\u0026#39;])} custom metrics\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;No custom metrics found\u0026#34;) # Check for alarms alarms_response = cloudwatch.describe_alarms() if alarms_response[\u0026#39;MetricAlarms\u0026#39;]: active_alarms = len([a for a in alarms_response[\u0026#39;MetricAlarms\u0026#39;] if a[\u0026#39;StateValue\u0026#39;] == \u0026#39;OK\u0026#39;]) test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;Found {len(alarms_response[\u0026#39;MetricAlarms\u0026#39;])} alarms, {active_alarms} in OK state\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;No CloudWatch alarms found\u0026#34;) except Exception as e: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;Monitoring system test failed: {str(e)}\u0026#34;) return test_result def test_compliance_validation(dynamodb): \u0026#34;\u0026#34;\u0026#34;Test compliance validation\u0026#34;\u0026#34;\u0026#34; test_result = { \u0026#39;test_name\u0026#39;: \u0026#39;Compliance Validation Test\u0026#39;, \u0026#39;status\u0026#39;: \u0026#39;PASS\u0026#39;, \u0026#39;details\u0026#39;: [], \u0026#39;errors\u0026#39;: [] } try: # Check for recent compliance assessments table = dynamodb.Table(\u0026#39;RiskAssessments\u0026#39;) response = table.scan( FilterExpression=\u0026#39;AssessmentType = :type\u0026#39;, ExpressionAttributeValues={\u0026#39;:type\u0026#39;: \u0026#39;Daily Operations Report\u0026#39;} ) if response[\u0026#39;Items\u0026#39;]: latest_assessment = max(response[\u0026#39;Items\u0026#39;], key=lambda x: x.get(\u0026#39;Date\u0026#39;, \u0026#39;\u0026#39;)) compliance_score = float(latest_assessment.get(\u0026#39;ComplianceScore\u0026#39;, 0)) test_result[\u0026#39;details\u0026#39;].append(f\u0026#34;Latest compliance score: {compliance_score}\u0026#34;) if compliance_score \u0026gt;= 70: test_result[\u0026#39;details\u0026#39;].append(\u0026#34;Compliance score meets minimum threshold\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;Compliance score ({compliance_score}) below threshold (70)\u0026#34;) else: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(\u0026#34;No compliance assessments found\u0026#34;) except Exception as e: test_result[\u0026#39;status\u0026#39;] = \u0026#39;FAIL\u0026#39; test_result[\u0026#39;errors\u0026#39;].append(f\u0026#34;Compliance validation test failed: {str(e)}\u0026#34;) return test_result Click Deploy 2.3 Chạy E2E Validation Test Click Test trong Lambda function Xem kết quả validation Xác minh tất cả tests PASS Bước 3: Compliance Verification 3.1 Generate Final Compliance Report Chạy AuditReportGenerator với report_type = \u0026lsquo;compliance\u0026rsquo; Xem compliance report trong S3 Xác minh compliance scores 3.2 Verify Security Controls Kiểm tra AWS Security Hub findings Xác minh không có critical findings Review security standards compliance Bước 4: Performance Validation 4.1 Kiểm tra System Performance Vào CloudWatch dashboard Xem performance metrics: Lambda execution times DynamoDB response times Error rates 4.2 Validate Scalability Kiểm tra auto-scaling configurations Xem resource utilization Validate cost optimization Bước 5: Final System Health Check 5.1 Comprehensive Health Dashboard Tạo final health check dashboard Bao gồm tất cả key metrics Xác minh system status = HEALTHY 5.2 Generate System Documentation Tạo Lambda function để generate system documentation Export configuration details Create operational runbooks Bước 6: Production Readiness Checklist 6.1 Security Checklist ✅ All IAM roles follow least privilege principle ✅ Encryption at rest enabled for all data stores ✅ Encryption in transit for all communications ✅ CloudTrail logging enabled and validated ✅ Security Hub findings reviewed and addressed ✅ No hardcoded credentials in code 6.2 Operational Checklist ✅ All Lambda functions have proper error handling ✅ CloudWatch alarms configured for critical metrics ✅ SNS notifications working for alerts ✅ Backup and recovery procedures documented ✅ Monitoring dashboards created and tested ✅ Operational runbooks completed 6.3 Compliance Checklist ✅ SOX compliance requirements met ✅ SOC2 controls implemented and tested ✅ ISO27001 requirements satisfied ✅ Audit trails complete and tamper-proof ✅ Access certification processes automated ✅ Risk assessment procedures operational Kết quả Cuối cùng Sau khi hoàn thành toàn bộ workshop:\n✅ Complete Identity Governance System - Hệ thống quản lý danh tính toàn diện ✅ Automated Access Certification - Tự động hóa chứng nhận truy cập ✅ Real-time Privilege Analytics - Phân tích đặc quyền thời gian thực ✅ Comprehensive Risk Assessment - Đánh giá rủi ro toàn diện ✅ Continuous Monitoring - Giám sát liên tục ✅ Automated Compliance Reporting - Báo cáo tuân thủ tự động ✅ Audit Trail System - Hệ thống audit trail ✅ Production-Ready Architecture - Kiến trúc sẵn sàng production Tiếp theo Chuyển sang 11. Clean Resources để dọn dẹp tài nguyên AWS sau khi hoàn thành workshop.\n"
},
{
	"uri": "//localhost:62814/vi/11-clean-resources/",
	"title": "11. Dọn dẹp Tài nguyên",
	"tags": [],
	"description": "",
	"content": "Tổng quan Phần này cung cấp hướng dẫn toàn diện để dọn dẹp tất cả tài nguyên AWS được tạo trong workshop Identity Governance nhằm tránh phát sinh chi phí không cần thiết.\nLưu ý quan trọng ⚠️ Cảnh báo: Thực hiện các bước dọn dẹp này sẽ xóa vĩnh viễn tất cả tài nguyên và dữ liệu được tạo trong workshop. Hãy đảm bảo bạn đã sao lưu các cấu hình hoặc dữ liệu quan trọng trước khi tiến hành.\nThứ tự Dọn dẹp Tài nguyên nên được dọn dẹp theo thứ tự sau để tránh xung đột phụ thuộc:\nLambda Functions và EventBridge Rules Step Functions State Machines DynamoDB Tables S3 Buckets và Objects CloudWatch Resources IAM Roles và Policies CloudFormation Stacks AWS Organizations (nếu đã tạo) IAM Identity Center (nếu không còn cần thiết) Bước 1: Lambda Functions và EventBridge Xóa Lambda Functions Mở AWS Lambda console Lọc functions theo tên workshop: IdentityGovernance AccessCertification ComplianceValidation Chọn workshop functions Click Actions → Delete Xác nhận xóa bằng cách gõ delete Xóa EventBridge Rules Mở Amazon EventBridge console Vào Rules Chọn workshop rules: AccessCertificationSchedule ComplianceValidationSchedule Click Delete cho từng rule Bước 2: Step Functions Mở AWS Step Functions console Chọn workshop state machines: AccessCertificationWorkflow ComplianceValidationWorkflow Click Delete Xác nhận xóa Bước 3: DynamoDB Tables Mở Amazon DynamoDB console Vào Tables Chọn workshop tables: OperationalProcedures ComplianceEvidence AuditFindings Click Delete cho từng table Gõ delete để xác nhận Bước 4: S3 Buckets Làm trống S3 Buckets Mở Amazon S3 console Xác định workshop buckets: privilege-analytics-* compliance-reports-* Chọn bucket và click Empty Gõ permanently delete để xác nhận Xóa S3 Buckets Sau khi làm trống, chọn bucket Click Delete Gõ tên bucket để xác nhận Bước 5: CloudWatch Resources Xóa CloudWatch Dashboards Mở Amazon CloudWatch console Vào Dashboards Chọn workshop dashboards: IdentityGovernanceRiskDashboard DailyOperationsDashboard Click Delete cho từng dashboard Xóa CloudWatch Alarms Vào Alarms Chọn workshop alarms Click Actions → Delete Xóa Log Groups Vào Log groups Chọn workshop log groups Click Actions → Delete log group Bước 6: SNS Topics Mở Amazon SNS console Vào Topics Chọn workshop topics: IdentityGovernanceAlerts ComplianceAlerts Click Delete cho từng topic Xác nhận xóa Bước 6: IAM Resources Xóa IAM Roles Điều hướng đến dịch vụ IAM trong AWS Console Click Roles trong sidebar Tìm kiếm các workshop roles: IdentityGovernanceLambdaRole ComplianceValidationRole CertificationWorkflowRole Chọn từng role và click Delete Gõ tên role để xác nhận xóa Xóa Custom IAM Policies Click Policies trong sidebar Lọc theo Customer managed Tìm kiếm các workshop policies: SecurityAuditPolicy IdentityGovernancePolicy ComplianceValidationPolicy Chọn từng policy và click Actions → Delete Xác nhận xóa Xóa IAM Users và Groups Click Users trong sidebar Chọn workshop users và click Delete Click User groups trong sidebar Chọn workshop groups và click Delete Bước 7: Dọn dẹp IAM Identity Center Xóa Permission Set Assignments Điều hướng đến IAM Identity Center Click AWS accounts trong sidebar Chọn account của bạn và click Remove access Xóa Permission Sets Click Permission sets trong sidebar Chọn các workshop permission sets: SecurityAuditor ComplianceReviewer Click Delete Xóa Users và Groups Click Users trong sidebar Chọn workshop users và click Delete Click Groups trong sidebar Chọn workshop groups và click Delete Bước 8: Dọn dẹp AWS Config Điều hướng đến dịch vụ AWS Config Click Settings trong sidebar Click Edit và sau đó Delete configuration recorder Xác nhận xóa bằng cách gõ delete Bước 9: Dọn dẹp CloudTrail Điều hướng đến dịch vụ CloudTrail Click Trails trong sidebar Chọn IdentityGovernanceTrail Click Delete Gõ tên trail để xác nhận xóa Checklist Dọn dẹp qua Console Để dọn dẹp có hệ thống qua AWS Console, hãy làm theo checklist này:\n✅ Checklist Dọn dẹp Lambda Functions:\nIdentityGovernanceMonitor AccessReviewGenerator ComplianceValidationEngine RiskAssessmentEngine CertificationNotifier EventBridge Rules:\nAccessCertificationSchedule ComplianceValidationSchedule RiskAssessmentSchedule Step Functions:\nAccessCertificationWorkflow ComplianceValidationWorkflow DynamoDB Tables:\nCertificationTasks OperationsLog ComplianceEvidence RiskMonitoring AuditFindings S3 Buckets:\nprivilege-analytics-[ACCOUNT-ID] compliance-reports-[ACCOUNT-ID] CloudWatch Resources:\nIdentityGovernanceRiskDashboard DailyOperationsDashboard Tất cả workshop alarms Tất cả workshop log groups SNS Topics:\nIdentityGovernanceAlerts ComplianceAlerts IAM Resources:\nWorkshop IAM roles Workshop IAM policies Workshop IAM users Workshop IAM groups IAM Identity Center:\nPermission set assignments Permission sets SSO users và groups Các Dịch vụ Khác:\nAWS Config recorder CloudTrail trail GuardDuty detector (nếu không cần) Bước 10: Xác minh Dọn dẹp Kiểm tra Tài nguyên Còn lại Kiểm tra AWS Cost Explorer để xác nhận không còn phí phát sinh Sử dụng AWS Resource Groups để tìm tagged resources Tìm kiếm tag: Project=IdentityGovernance Kiểm tra Dịch vụ Cuối cùng AWS Config: Tắt configuration recorder nếu không cần AWS Security Hub: Tắt nếu không sử dụng ở nơi khác Amazon GuardDuty: Tắt nếu không cần AWS Audit Manager: Tắt data collection Báo cáo Xác minh Dọn dẹp Tạo báo cáo tóm tắt dọn dẹp Ghi chép các tài nguyên không thể xóa Lưu ý các phí đang phát sinh Xác minh Chi phí Sau khi dọn dẹp, hãy theo dõi dashboard billing AWS để đảm bảo không có phí phát sinh từ tài nguyên còn lại.\nKhắc phục Sự cố Vấn đề Thường gặp Lỗi Phụ thuộc: Một số tài nguyên có thể có phụ thuộc. Hãy xóa tài nguyên phụ thuộc trước. Lỗi Quyền: Đảm bảo bạn có đủ quyền để xóa tất cả tài nguyên. Vấn đề Region: Đảm bảo bạn đang xóa tài nguyên ở đúng region. Dọn dẹp Thủ công Nếu dọn dẹp tự động thất bại, hãy xóa tài nguyên thủ công qua AWS Console:\nTruy cập console của từng service Tìm kiếm tài nguyên có tên chứa \u0026ldquo;IdentityGovernance\u0026rdquo;, \u0026ldquo;Compliance\u0026rdquo;, hoặc \u0026ldquo;Certification\u0026rdquo; Xóa từng tài nguyên một cách riêng lẻ Ghi chú Cuối Việc dọn dẹp này sẽ xóa TẤT CẢ tài nguyên workshop Kiểm tra kỹ trước khi chạy lệnh dọn dẹp Một số tài nguyên có thể có độ trễ ngắn trước khi bị xóa Theo dõi hóa đơn AWS để đảm bảo không có phí tiếp tục phát sinh Dọn dẹp workshop hoàn tất! 🎉\n"
},
{
	"uri": "//localhost:62814/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:62814/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]